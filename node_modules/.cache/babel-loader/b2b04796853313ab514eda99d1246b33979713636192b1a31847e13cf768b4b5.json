{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.defaultConfig = exports[\"default\"] = void 0;\nvar _reactFastCompare = _interopRequireDefault(require(\"react-fast-compare\"));\nvar _utils = require(\"./utils\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nvar defaultConfig = {\n  color: '#dee4fd',\n  radius: [0.5, 3.0],\n  speed: [1.0, 3.0],\n  wind: [-0.5, 2.0],\n  changeFrequency: 200,\n  rotationSpeed: [-1.0, 1.0]\n};\nexports.defaultConfig = defaultConfig;\n\n/**\r\n * An individual snowflake that will update it's location every call to `update`\r\n * and draw itself to the canvas every call to `draw`.\r\n */\nvar Snowflake = /*#__PURE__*/function () {\n  function Snowflake(canvas) {\n    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, Snowflake);\n    _defineProperty(this, \"config\", void 0);\n    _defineProperty(this, \"params\", void 0);\n    _defineProperty(this, \"framesSinceLastUpdate\", void 0);\n    _defineProperty(this, \"image\", void 0);\n\n    // Set custom config\n    this.updateConfig(config); // Setting initial parameters\n\n    var _this$config = this.config,\n      radius = _this$config.radius,\n      wind = _this$config.wind,\n      speed = _this$config.speed,\n      rotationSpeed = _this$config.rotationSpeed;\n    this.params = {\n      x: (0, _utils.random)(0, canvas.offsetWidth),\n      y: (0, _utils.random)(-canvas.offsetHeight, 0),\n      rotation: (0, _utils.random)(0, 360),\n      radius: _utils.random.apply(void 0, _toConsumableArray(radius)),\n      speed: _utils.random.apply(void 0, _toConsumableArray(speed)),\n      wind: _utils.random.apply(void 0, _toConsumableArray(wind)),\n      rotationSpeed: _utils.random.apply(void 0, _toConsumableArray(rotationSpeed)),\n      nextSpeed: _utils.random.apply(void 0, _toConsumableArray(wind)),\n      nextWind: _utils.random.apply(void 0, _toConsumableArray(speed)),\n      nextRotationSpeed: _utils.random.apply(void 0, _toConsumableArray(rotationSpeed))\n    };\n    this.framesSinceLastUpdate = 0;\n  }\n  _createClass(Snowflake, [{\n    key: \"selectImage\",\n    value: function selectImage() {\n      if (this.config.images && this.config.images.length > 0) {\n        this.image = (0, _utils.randomElement)(this.config.images);\n      } else {\n        this.image = undefined;\n      }\n    }\n  }, {\n    key: \"updateConfig\",\n    value: function updateConfig(config) {\n      var previousConfig = this.config;\n      this.config = _objectSpread(_objectSpread({}, defaultConfig), config);\n      this.config.changeFrequency = (0, _utils.random)(this.config.changeFrequency, this.config.changeFrequency * 1.5); // Update the radius if the config has changed, it won't gradually update on it's own\n\n      if (this.params && !(0, _reactFastCompare[\"default\"])(this.config.radius, previousConfig === null || previousConfig === void 0 ? void 0 : previousConfig.radius)) {\n        this.params.radius = _utils.random.apply(void 0, _toConsumableArray(this.config.radius));\n      }\n      if (!(0, _reactFastCompare[\"default\"])(this.config.images, previousConfig === null || previousConfig === void 0 ? void 0 : previousConfig.images)) {\n        this.selectImage();\n      }\n    }\n  }, {\n    key: \"updateTargetParams\",\n    value: function updateTargetParams() {\n      this.params.nextSpeed = _utils.random.apply(void 0, _toConsumableArray(this.config.speed));\n      this.params.nextWind = _utils.random.apply(void 0, _toConsumableArray(this.config.wind));\n      if (this.image) {\n        this.params.nextRotationSpeed = _utils.random.apply(void 0, _toConsumableArray(this.config.rotationSpeed));\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update(canvas) {\n      var framesPassed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var _this$params = this.params,\n        x = _this$params.x,\n        y = _this$params.y,\n        rotation = _this$params.rotation,\n        rotationSpeed = _this$params.rotationSpeed,\n        nextRotationSpeed = _this$params.nextRotationSpeed,\n        wind = _this$params.wind,\n        speed = _this$params.speed,\n        nextWind = _this$params.nextWind,\n        nextSpeed = _this$params.nextSpeed,\n        radius = _this$params.radius; // Update current location, wrapping around if going off the canvas\n\n      this.params.x = (x + wind * framesPassed) % (canvas.offsetWidth + radius * 2);\n      if (this.params.x > canvas.offsetWidth + radius) this.params.x = -radius;\n      this.params.y = (y + speed * framesPassed) % (canvas.offsetHeight + radius * 2);\n      if (this.params.y > canvas.offsetHeight + radius) this.params.y = -radius; // Apply rotation\n\n      if (this.image) {\n        this.params.rotation = (rotation + rotationSpeed) % 360;\n      } // Update the wind, speed and rotation towards the desired values\n\n      this.params.speed = (0, _utils.lerp)(speed, nextSpeed, 0.01);\n      this.params.wind = (0, _utils.lerp)(wind, nextWind, 0.01);\n      this.params.rotationSpeed = (0, _utils.lerp)(rotationSpeed, nextRotationSpeed, 0.01);\n      if (this.framesSinceLastUpdate++ > this.config.changeFrequency) {\n        this.updateTargetParams();\n        this.framesSinceLastUpdate = 0;\n      }\n    }\n  }, {\n    key: \"getImageOffscreenCanvas\",\n    value: function getImageOffscreenCanvas(image, size) {\n      var _sizes$size;\n      if (image instanceof HTMLImageElement && image.loading) return image;\n      var sizes = Snowflake.offscreenCanvases.get(image);\n      if (!sizes) {\n        sizes = {};\n        Snowflake.offscreenCanvases.set(image, sizes);\n      }\n      if (!(size in sizes)) {\n        var _canvas$getContext;\n        var canvas = document.createElement('canvas');\n        canvas.width = size;\n        canvas.height = size;\n        (_canvas$getContext = canvas.getContext('2d')) === null || _canvas$getContext === void 0 ? void 0 : _canvas$getContext.drawImage(image, 0, 0, size, size);\n        sizes[size] = canvas;\n      }\n      return (_sizes$size = sizes[size]) !== null && _sizes$size !== void 0 ? _sizes$size : image;\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(ctx) {\n      if (this.image) {\n        // ctx.save()\n        // ctx.translate(this.params.x, this.params.y)\n        ctx.setTransform(1, 0, 0, 1, this.params.x, this.params.y);\n        var radius = Math.ceil(this.params.radius);\n        ctx.rotate(this.params.rotation * Math.PI / 180);\n        ctx.drawImage(this.getImageOffscreenCanvas(this.image, radius), -Math.ceil(radius / 2), -Math.ceil(radius / 2), radius, radius); // ctx.restore()\n      } else {\n        ctx.beginPath();\n        ctx.arc(this.params.x, this.params.y, this.params.radius, 0, 2 * Math.PI);\n        ctx.fillStyle = this.config.color;\n        ctx.closePath();\n        ctx.fill();\n      }\n    }\n  }]);\n  return Snowflake;\n}();\n_defineProperty(Snowflake, \"offscreenCanvases\", new WeakMap());\nvar _default = Snowflake;\nexports[\"default\"] = _default;","map":{"version":3,"mappings":"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","names":["defaultConfig","color","radius","speed","wind","changeFrequency","rotationSpeed","Snowflake","canvas","config","_classCallCheck","_defineProperty","updateConfig","params","x","offsetWidth","y","offsetHeight","rotation","random","nextSpeed","nextWind","nextRotationSpeed","framesSinceLastUpdate","images","length","image","undefined","previousConfig","selectImage","framesPassed","updateTargetParams","size","HTMLImageElement","loading","sizes","offscreenCanvases","get","set","document","createElement","width","height","getContext","drawImage","ctx","setTransform","Math","ceil","rotate","PI","getImageOffscreenCanvas","beginPath","arc","fillStyle","closePath","fill","WeakMap"],"sources":["C:\\Users\\HP\\Desktop\\new try\\METAMORPH_2K21\\node_modules\\react-snowfall\\src\\Snowflake.ts"],"sourcesContent":["import isEqual from 'react-fast-compare'\r\nimport { lerp, random, randomElement } from './utils'\r\n\r\nexport interface SnowflakeProps {\r\n  /** The color of the snowflake, can be any valid CSS color. */\r\n  color: string\r\n  /**\r\n   * The minimum and maximum radius of the snowflake, will be\r\n   * randomly selected within this range.\r\n   *\r\n   * The default value is `[0.5, 3.0]`.\r\n   */\r\n  radius: [number, number]\r\n  /**\r\n   * The minimum and maximum speed of the snowflake.\r\n   *\r\n   * The speed determines how quickly the snowflake moves\r\n   * along the y axis (vertical speed).\r\n   *\r\n   * The values will be randomly selected within this range.\r\n   *\r\n   * The default value is `[1.0, 3.0]`.\r\n   */\r\n  speed: [number, number]\r\n  /**\r\n   * The minimum and maximum wind of the snowflake.\r\n   *\r\n   * The wind determines how quickly the snowflake moves\r\n   * along the x axis (horizontal speed).\r\n   *\r\n   * The values will be randomly selected within this range.\r\n   *\r\n   * The default value is `[-0.5, 2.0]`.\r\n   */\r\n  wind: [number, number]\r\n  /**\r\n   * The frequency in frames that the wind and speed values\r\n   * will update.\r\n   *\r\n   * The default value is 200.\r\n   */\r\n  changeFrequency: number\r\n  /**\r\n   * An array of images that will be rendered as the snowflakes instead\r\n   * of the default circle shapes.\r\n   */\r\n  images?: CanvasImageSource[]\r\n  /**\r\n   * The minimum and maximum rotation speed of the snowflake (in degrees of\r\n   * rotation per frame).\r\n   *\r\n   * The rotation speed determines how quickly the snowflake rotates when\r\n   * an image is being rendered.\r\n   *\r\n   * The values will be randomly selected within this range.\r\n   *\r\n   * The default value is `[-1.0, 1.0]`.\r\n   */\r\n  rotationSpeed: [number, number]\r\n}\r\n\r\nexport type SnowflakeConfig = Partial<SnowflakeProps>\r\n\r\nexport const defaultConfig: SnowflakeProps = {\r\n  color: '#dee4fd',\r\n  radius: [0.5, 3.0],\r\n  speed: [1.0, 3.0],\r\n  wind: [-0.5, 2.0],\r\n  changeFrequency: 200,\r\n  rotationSpeed: [-1.0, 1.0],\r\n}\r\n\r\ninterface SnowflakeParams {\r\n  x: number\r\n  y: number\r\n  radius: number\r\n  rotation: number\r\n  rotationSpeed: number\r\n  speed: number\r\n  wind: number\r\n  nextSpeed: number\r\n  nextWind: number\r\n  nextRotationSpeed: number\r\n}\r\n\r\n/**\r\n * An individual snowflake that will update it's location every call to `update`\r\n * and draw itself to the canvas every call to `draw`.\r\n */\r\nclass Snowflake {\r\n  static offscreenCanvases = new WeakMap<CanvasImageSource, Record<number, HTMLCanvasElement>>()\r\n\r\n  private config!: SnowflakeProps\r\n  private params: SnowflakeParams\r\n  private framesSinceLastUpdate: number\r\n  private image?: CanvasImageSource\r\n\r\n  public constructor(canvas: HTMLCanvasElement, config: SnowflakeConfig = {}) {\r\n    // Set custom config\r\n    this.updateConfig(config)\r\n\r\n    // Setting initial parameters\r\n    const { radius, wind, speed, rotationSpeed } = this.config\r\n\r\n    this.params = {\r\n      x: random(0, canvas.offsetWidth),\r\n      y: random(-canvas.offsetHeight, 0),\r\n      rotation: random(0, 360),\r\n      radius: random(...radius),\r\n      speed: random(...speed),\r\n      wind: random(...wind),\r\n      rotationSpeed: random(...rotationSpeed),\r\n      nextSpeed: random(...wind),\r\n      nextWind: random(...speed),\r\n      nextRotationSpeed: random(...rotationSpeed),\r\n    }\r\n\r\n    this.framesSinceLastUpdate = 0\r\n  }\r\n\r\n  private selectImage() {\r\n    if (this.config.images && this.config.images.length > 0) {\r\n      this.image = randomElement(this.config.images)\r\n    } else {\r\n      this.image = undefined\r\n    }\r\n  }\r\n\r\n  public updateConfig(config: SnowflakeConfig): void {\r\n    const previousConfig = this.config\r\n    this.config = { ...defaultConfig, ...config }\r\n    this.config.changeFrequency = random(this.config.changeFrequency, this.config.changeFrequency * 1.5)\r\n\r\n    // Update the radius if the config has changed, it won't gradually update on it's own\r\n    if (this.params && !isEqual(this.config.radius, previousConfig?.radius)) {\r\n      this.params.radius = random(...this.config.radius)\r\n    }\r\n\r\n    if (!isEqual(this.config.images, previousConfig?.images)) {\r\n      this.selectImage()\r\n    }\r\n  }\r\n\r\n  private updateTargetParams(): void {\r\n    this.params.nextSpeed = random(...this.config.speed)\r\n    this.params.nextWind = random(...this.config.wind)\r\n    if (this.image) {\r\n      this.params.nextRotationSpeed = random(...this.config.rotationSpeed)\r\n    }\r\n  }\r\n\r\n  public update(canvas: HTMLCanvasElement, framesPassed = 1): void {\r\n    const { x, y, rotation, rotationSpeed, nextRotationSpeed, wind, speed, nextWind, nextSpeed, radius } = this.params\r\n\r\n    // Update current location, wrapping around if going off the canvas\r\n    this.params.x = (x + wind * framesPassed) % (canvas.offsetWidth + radius * 2)\r\n    if (this.params.x > canvas.offsetWidth + radius) this.params.x = -radius\r\n    this.params.y = (y + speed * framesPassed) % (canvas.offsetHeight + radius * 2)\r\n    if (this.params.y > canvas.offsetHeight + radius) this.params.y = -radius\r\n\r\n    // Apply rotation\r\n    if (this.image) {\r\n      this.params.rotation = (rotation + rotationSpeed) % 360\r\n    }\r\n\r\n    // Update the wind, speed and rotation towards the desired values\r\n    this.params.speed = lerp(speed, nextSpeed, 0.01)\r\n    this.params.wind = lerp(wind, nextWind, 0.01)\r\n    this.params.rotationSpeed = lerp(rotationSpeed, nextRotationSpeed, 0.01)\r\n\r\n    if (this.framesSinceLastUpdate++ > this.config.changeFrequency) {\r\n      this.updateTargetParams()\r\n      this.framesSinceLastUpdate = 0\r\n    }\r\n  }\r\n\r\n  private getImageOffscreenCanvas(image: CanvasImageSource, size: number): CanvasImageSource {\r\n    if (image instanceof HTMLImageElement && image.loading) return image\r\n    let sizes = Snowflake.offscreenCanvases.get(image)\r\n\r\n    if (!sizes) {\r\n      sizes = {}\r\n      Snowflake.offscreenCanvases.set(image, sizes)\r\n    }\r\n\r\n    if (!(size in sizes)) {\r\n      const canvas = document.createElement('canvas')\r\n      canvas.width = size\r\n      canvas.height = size\r\n      canvas.getContext('2d')?.drawImage(image, 0, 0, size, size)\r\n      sizes[size] = canvas\r\n    }\r\n\r\n    return sizes[size] ?? image\r\n  }\r\n\r\n  public draw(ctx: CanvasRenderingContext2D): void {\r\n    if (this.image) {\r\n      // ctx.save()\r\n      // ctx.translate(this.params.x, this.params.y)\r\n      ctx.setTransform(1, 0, 0, 1, this.params.x, this.params.y)\r\n\r\n      const radius = Math.ceil(this.params.radius)\r\n      ctx.rotate((this.params.rotation * Math.PI) / 180)\r\n      ctx.drawImage(\r\n        this.getImageOffscreenCanvas(this.image, radius),\r\n        -Math.ceil(radius / 2),\r\n        -Math.ceil(radius / 2),\r\n        radius,\r\n        radius,\r\n      )\r\n\r\n      // ctx.restore()\r\n    } else {\r\n      ctx.beginPath()\r\n      ctx.arc(this.params.x, this.params.y, this.params.radius, 0, 2 * Math.PI)\r\n      ctx.fillStyle = this.config.color\r\n      ctx.closePath()\r\n      ctx.fill()\r\n    }\r\n  }\r\n}\r\n\r\nexport default Snowflake\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}