{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar react = require('react');\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction Alignment(align, viewSize) {\n  var predefined = {\n    start: start,\n    center: center,\n    end: end\n  };\n  function start() {\n    return 0;\n  }\n  function center(n) {\n    return end(n) / 2;\n  }\n  function end(n) {\n    return viewSize - n;\n  }\n  function percent() {\n    return viewSize * Number(align);\n  }\n  function measure(n) {\n    if (typeof align === 'number') return percent();\n    return predefined[align](n);\n  }\n  var self = {\n    measure: measure\n  };\n  return self;\n}\nfunction Animation(callback) {\n  var animationFrame = 0;\n  function ifAnimating(active, cb) {\n    return function () {\n      if (active === !!animationFrame) cb();\n    };\n  }\n  function start() {\n    animationFrame = window.requestAnimationFrame(callback);\n  }\n  function stop() {\n    window.cancelAnimationFrame(animationFrame);\n    animationFrame = 0;\n  }\n  var self = {\n    proceed: ifAnimating(true, start),\n    start: ifAnimating(false, start),\n    stop: ifAnimating(true, stop)\n  };\n  return self;\n}\nfunction Axis(axis, contentDirection) {\n  var scroll = axis === 'y' ? 'y' : 'x';\n  var cross = axis === 'y' ? 'x' : 'y';\n  var startEdge = getStartEdge();\n  var endEdge = getEndEdge();\n  function measureSize(rect) {\n    var width = rect.width,\n      height = rect.height;\n    return scroll === 'x' ? width : height;\n  }\n  function getStartEdge() {\n    if (scroll === 'y') return 'top';\n    return contentDirection === 'rtl' ? 'right' : 'left';\n  }\n  function getEndEdge() {\n    if (scroll === 'y') return 'bottom';\n    return contentDirection === 'rtl' ? 'left' : 'right';\n  }\n  var self = {\n    scroll: scroll,\n    cross: cross,\n    startEdge: startEdge,\n    endEdge: endEdge,\n    measureSize: measureSize\n  };\n  return self;\n}\nfunction Limit(min, max) {\n  var length = Math.abs(min - max);\n  function reachedMin(n) {\n    return n < min;\n  }\n  function reachedMax(n) {\n    return n > max;\n  }\n  function reachedAny(n) {\n    return reachedMin(n) || reachedMax(n);\n  }\n  function constrain(n) {\n    if (!reachedAny(n)) return n;\n    return reachedMin(n) ? min : max;\n  }\n  function removeOffset(n) {\n    if (!length) return n;\n    return n - length * Math.ceil((n - max) / length);\n  }\n  var self = {\n    constrain: constrain,\n    length: length,\n    max: max,\n    min: min,\n    reachedAny: reachedAny,\n    reachedMax: reachedMax,\n    reachedMin: reachedMin,\n    removeOffset: removeOffset\n  };\n  return self;\n}\nfunction Counter(max, start, loop) {\n  var _a = Limit(0, max),\n    min = _a.min,\n    constrain = _a.constrain;\n  var loopEnd = max + 1;\n  var counter = withinLimit(start);\n  function withinLimit(n) {\n    return !loop ? constrain(n) : Math.abs((loopEnd + n) % loopEnd);\n  }\n  function get() {\n    return counter;\n  }\n  function set(n) {\n    counter = withinLimit(n);\n    return self;\n  }\n  function add(n) {\n    return set(get() + n);\n  }\n  function clone() {\n    return Counter(max, get(), loop);\n  }\n  var self = {\n    add: add,\n    clone: clone,\n    get: get,\n    set: set,\n    min: min,\n    max: max\n  };\n  return self;\n}\nfunction Direction(direction) {\n  var sign = direction === 'rtl' ? -1 : 1;\n  function applyTo(n) {\n    return n * sign;\n  }\n  var self = {\n    applyTo: applyTo\n  };\n  return self;\n}\nfunction EventStore() {\n  var listeners = [];\n  function add(node, type, handler, options) {\n    if (options === void 0) {\n      options = false;\n    }\n    node.addEventListener(type, handler, options);\n    listeners.push(function () {\n      return node.removeEventListener(type, handler, options);\n    });\n    return self;\n  }\n  function removeAll() {\n    listeners = listeners.filter(function (remove) {\n      return remove();\n    });\n    return self;\n  }\n  var self = {\n    add: add,\n    removeAll: removeAll\n  };\n  return self;\n}\nfunction Vector1D(value) {\n  var vector = value;\n  function get() {\n    return vector;\n  }\n  function set(n) {\n    vector = readNumber(n);\n    return self;\n  }\n  function add(n) {\n    vector += readNumber(n);\n    return self;\n  }\n  function subtract(n) {\n    vector -= readNumber(n);\n    return self;\n  }\n  function multiply(n) {\n    vector *= n;\n    return self;\n  }\n  function divide(n) {\n    vector /= n;\n    return self;\n  }\n  function normalize() {\n    if (vector !== 0) divide(vector);\n    return self;\n  }\n  function readNumber(n) {\n    return typeof n === 'number' ? n : n.get();\n  }\n  var self = {\n    add: add,\n    divide: divide,\n    get: get,\n    multiply: multiply,\n    normalize: normalize,\n    set: set,\n    subtract: subtract\n  };\n  return self;\n}\nfunction map(value, iStart, iStop, oStart, oStop) {\n  return oStart + (oStop - oStart) * ((value - iStart) / (iStop - iStart));\n}\nfunction mathSign(n) {\n  return !n ? 0 : n / Math.abs(n);\n}\nfunction deltaAbs(valueB, valueA) {\n  return Math.abs(valueB - valueA);\n}\nfunction factorAbs(valueB, valueA) {\n  if (valueB === 0 || valueA === 0) return 0;\n  if (Math.abs(valueB) <= Math.abs(valueA)) return 0;\n  var diff = deltaAbs(Math.abs(valueB), Math.abs(valueA));\n  return Math.abs(diff / valueB);\n}\nfunction roundToDecimals(decimalPoints) {\n  var pow = Math.pow(10, decimalPoints);\n  return function (n) {\n    return Math.round(n * pow) / pow;\n  };\n}\nfunction debounce(callback, time) {\n  var timeout = 0;\n  return function () {\n    window.clearTimeout(timeout);\n    timeout = window.setTimeout(callback, time) || 0;\n  };\n}\nfunction groupArray(array, size) {\n  var groups = [];\n  for (var i = 0; i < array.length; i += size) {\n    groups.push(array.slice(i, i + size));\n  }\n  return groups;\n}\nfunction arrayKeys(array) {\n  return Object.keys(array).map(Number);\n}\nfunction arrayLast(array) {\n  return array[lastIndex(array)];\n}\nfunction lastIndex(array) {\n  return Math.max(0, array.length - 1);\n}\nfunction removeClass(node, className) {\n  var cl = node.classList;\n  if (className && cl.contains(className)) cl.remove(className);\n}\nfunction addClass(node, className) {\n  var cl = node.classList;\n  if (className && !cl.contains(className)) cl.add(className);\n}\nfunction DragHandler(axis, direction, rootNode, target, dragFree, dragTracker, location, animation, scrollTo, scrollBody, scrollTarget, index, events, loop, skipSnaps) {\n  var scrollAxis = axis.scroll,\n    crossAxis = axis.cross;\n  var focusNodes = ['INPUT', 'SELECT', 'TEXTAREA'];\n  var startScroll = Vector1D(0);\n  var startCross = Vector1D(0);\n  var dragStartPoint = Vector1D(0);\n  var activationEvents = EventStore();\n  var interactionEvents = EventStore();\n  var snapForceBoost = {\n    mouse: 2.5,\n    touch: 3.5\n  };\n  var freeForceBoost = {\n    mouse: 5,\n    touch: 7\n  };\n  var baseSpeed = dragFree ? 5 : 16;\n  var baseMass = 1;\n  var dragThreshold = 20;\n  var pointerIsDown = false;\n  var preventScroll = false;\n  var preventClick = false;\n  var isMouse = false;\n  function addActivationEvents() {\n    var node = rootNode;\n    activationEvents.add(node, 'touchmove', function () {\n      return undefined;\n    }).add(node, 'touchend', function () {\n      return undefined;\n    }).add(node, 'touchstart', down).add(node, 'mousedown', down).add(node, 'touchcancel', up).add(node, 'contextmenu', up).add(node, 'click', click);\n  }\n  function addInteractionEvents() {\n    var node = !isMouse ? rootNode : document;\n    interactionEvents.add(node, 'touchmove', move).add(node, 'touchend', up).add(node, 'mousemove', move).add(node, 'mouseup', up);\n  }\n  function removeAllEvents() {\n    activationEvents.removeAll();\n    interactionEvents.removeAll();\n  }\n  function isFocusNode(node) {\n    var name = node.nodeName || '';\n    return focusNodes.indexOf(name) > -1;\n  }\n  function forceBoost() {\n    var boost = dragFree ? freeForceBoost : snapForceBoost;\n    var type = isMouse ? 'mouse' : 'touch';\n    return boost[type];\n  }\n  function allowedForce(force, targetChanged) {\n    var next = index.clone().add(mathSign(force) * -1);\n    var isEdge = next.get() === index.min || next.get() === index.max;\n    var baseForce = scrollTarget.byDistance(force, !dragFree).distance;\n    if (dragFree || Math.abs(force) < dragThreshold) return baseForce;\n    if (!loop && isEdge) return baseForce * 0.6;\n    if (skipSnaps && targetChanged) return baseForce * 0.5;\n    return scrollTarget.byIndex(next.get(), 0).distance;\n  }\n  function down(evt) {\n    isMouse = evt.type === 'mousedown';\n    if (isMouse && evt.button !== 0) return;\n    var isMoving = deltaAbs(target.get(), location.get()) >= 2;\n    var clearPreventClick = isMouse || !isMoving;\n    var isNotFocusNode = !isFocusNode(evt.target);\n    var preventDefault = isMoving || isMouse && isNotFocusNode;\n    pointerIsDown = true;\n    dragTracker.pointerDown(evt);\n    dragStartPoint.set(target);\n    target.set(location);\n    scrollBody.useBaseMass().useSpeed(80);\n    addInteractionEvents();\n    startScroll.set(dragTracker.readPoint(evt, scrollAxis));\n    startCross.set(dragTracker.readPoint(evt, crossAxis));\n    events.emit('pointerDown');\n    if (clearPreventClick) preventClick = false;\n    if (preventDefault) evt.preventDefault();\n  }\n  function move(evt) {\n    if (!preventScroll && !isMouse) {\n      if (!evt.cancelable) return up();\n      var moveScroll = dragTracker.readPoint(evt, scrollAxis).get();\n      var moveCross = dragTracker.readPoint(evt, crossAxis).get();\n      var diffScroll = deltaAbs(moveScroll, startScroll.get());\n      var diffCross = deltaAbs(moveCross, startCross.get());\n      preventScroll = diffScroll > diffCross;\n      if (!preventScroll && !preventClick) return up();\n    }\n    var diff = dragTracker.pointerMove(evt);\n    if (!preventClick && diff) preventClick = true;\n    animation.start();\n    target.add(direction.applyTo(diff));\n    evt.preventDefault();\n  }\n  function up() {\n    var currentLocation = scrollTarget.byDistance(0, false);\n    var targetChanged = currentLocation.index !== index.get();\n    var rawForce = dragTracker.pointerUp() * forceBoost();\n    var force = allowedForce(direction.applyTo(rawForce), targetChanged);\n    var forceFactor = factorAbs(rawForce, force);\n    var isMoving = deltaAbs(target.get(), dragStartPoint.get()) >= 0.5;\n    var isVigorous = targetChanged && forceFactor > 0.75;\n    var isBelowThreshold = Math.abs(rawForce) < dragThreshold;\n    var speed = isVigorous ? 10 : baseSpeed;\n    var mass = isVigorous ? baseMass + 2.5 * forceFactor : baseMass;\n    if (isMoving && !isMouse) preventClick = true;\n    preventScroll = false;\n    pointerIsDown = false;\n    interactionEvents.removeAll();\n    scrollBody.useSpeed(isBelowThreshold ? 9 : speed).useMass(mass);\n    scrollTo.distance(force, !dragFree);\n    isMouse = false;\n    events.emit('pointerUp');\n  }\n  function click(evt) {\n    if (preventClick) evt.preventDefault();\n  }\n  function clickAllowed() {\n    return !preventClick;\n  }\n  function pointerDown() {\n    return pointerIsDown;\n  }\n  var self = {\n    addActivationEvents: addActivationEvents,\n    clickAllowed: clickAllowed,\n    pointerDown: pointerDown,\n    removeAllEvents: removeAllEvents\n  };\n  return self;\n}\nfunction DragTracker(axis, pxToPercent) {\n  var scrollAxis = axis.scroll;\n  var coords = {\n    x: 'clientX',\n    y: 'clientY'\n  };\n  var startDrag = Vector1D(0);\n  var diffDrag = Vector1D(0);\n  var lastDrag = Vector1D(0);\n  var pointValue = Vector1D(0);\n  var trackInterval = 10;\n  var trackLength = 5;\n  var trackTime = 100;\n  var trackPoints = [];\n  var lastMoveTime = new Date().getTime();\n  var isMouse = false;\n  function readPoint(evt, type) {\n    isMouse = !evt.touches;\n    var c = coords[type];\n    var value = isMouse ? evt[c] : evt.touches[0][c];\n    return pointValue.set(value);\n  }\n  function pointerDown(evt) {\n    var point = readPoint(evt, scrollAxis);\n    startDrag.set(point);\n    lastDrag.set(point);\n    return pxToPercent.measure(startDrag.get());\n  }\n  function pointerMove(evt) {\n    var point = readPoint(evt, scrollAxis);\n    var nowTime = new Date().getTime();\n    var diffTime = nowTime - lastMoveTime;\n    if (diffTime >= trackInterval) {\n      if (diffTime >= trackTime) trackPoints = [];\n      trackPoints.push(point.get());\n      lastMoveTime = nowTime;\n    }\n    diffDrag.set(point).subtract(lastDrag);\n    lastDrag.set(point);\n    return pxToPercent.measure(diffDrag.get());\n  }\n  function pointerUp() {\n    var nowTime = new Date().getTime();\n    var diffTime = nowTime - lastMoveTime;\n    var currentPoint = lastDrag.get();\n    var force = trackPoints.slice(-trackLength).map(function (trackPoint) {\n      return currentPoint - trackPoint;\n    }).sort(function (p1, p2) {\n      return Math.abs(p1) < Math.abs(p2) ? 1 : -1;\n    })[0];\n    lastDrag.set(diffTime > trackTime || !force ? 0 : force);\n    trackPoints = [];\n    return pxToPercent.measure(lastDrag.get());\n  }\n  var self = {\n    pointerDown: pointerDown,\n    pointerMove: pointerMove,\n    pointerUp: pointerUp,\n    readPoint: readPoint\n  };\n  return self;\n}\nfunction PxToPercent(viewInPx) {\n  var totalPercent = 100;\n  function measure(n) {\n    if (viewInPx === 0) return 0;\n    return n / viewInPx * totalPercent;\n  }\n  var self = {\n    measure: measure,\n    totalPercent: totalPercent\n  };\n  return self;\n}\nfunction ScrollBody(location, baseSpeed, baseMass) {\n  var roundToTwoDecimals = roundToDecimals(2);\n  var velocity = Vector1D(0);\n  var acceleration = Vector1D(0);\n  var attraction = Vector1D(0);\n  var attractionDirection = 0;\n  var speed = baseSpeed;\n  var mass = baseMass;\n  function update() {\n    velocity.add(acceleration);\n    location.add(velocity);\n    acceleration.multiply(0);\n  }\n  function applyForce(v) {\n    v.divide(mass);\n    acceleration.add(v);\n  }\n  function seek(v) {\n    attraction.set(v).subtract(location);\n    var magnitude = map(attraction.get(), 0, 100, 0, speed);\n    attractionDirection = mathSign(attraction.get());\n    attraction.normalize().multiply(magnitude).subtract(velocity);\n    applyForce(attraction);\n    return self;\n  }\n  function settle(v) {\n    var diff = v.get() - location.get();\n    var hasSettled = !roundToTwoDecimals(diff);\n    if (hasSettled) location.set(v);\n    return hasSettled;\n  }\n  function direction() {\n    return attractionDirection;\n  }\n  function useBaseSpeed() {\n    return useSpeed(baseSpeed);\n  }\n  function useBaseMass() {\n    return useMass(baseMass);\n  }\n  function useSpeed(n) {\n    speed = n;\n    return self;\n  }\n  function useMass(n) {\n    mass = n;\n    return self;\n  }\n  var self = {\n    direction: direction,\n    seek: seek,\n    settle: settle,\n    update: update,\n    useBaseMass: useBaseMass,\n    useBaseSpeed: useBaseSpeed,\n    useMass: useMass,\n    useSpeed: useSpeed\n  };\n  return self;\n}\nfunction ScrollBounds(limit, location, target, scrollBody) {\n  var pullBackThreshold = 10;\n  var disabled = false;\n  function shouldConstrain() {\n    if (disabled) return false;\n    if (!limit.reachedAny(target.get())) return false;\n    if (!limit.reachedAny(location.get())) return false;\n    return true;\n  }\n  function constrain(pointerDown) {\n    if (!shouldConstrain()) return;\n    var friction = pointerDown ? 0.7 : 0.45;\n    var diffToTarget = target.get() - location.get();\n    target.subtract(diffToTarget * friction);\n    if (!pointerDown && Math.abs(diffToTarget) < pullBackThreshold) {\n      target.set(limit.constrain(target.get()));\n      scrollBody.useSpeed(10).useMass(3);\n    }\n  }\n  function toggleActive(active) {\n    disabled = !active;\n  }\n  var self = {\n    constrain: constrain,\n    toggleActive: toggleActive\n  };\n  return self;\n}\nfunction ScrollContain(viewSize, contentSize, snaps, snapsAligned, containScroll) {\n  var scrollBounds = Limit(-contentSize + viewSize, snaps[0]);\n  var snapsBounded = snapsAligned.map(scrollBounds.constrain);\n  var snapsContained = measureContained();\n  function findDuplicates() {\n    var startSnap = snapsBounded[0];\n    var endSnap = arrayLast(snapsBounded);\n    var min = snapsBounded.lastIndexOf(startSnap);\n    var max = snapsBounded.indexOf(endSnap) + 1;\n    return Limit(min, max);\n  }\n  function measureContained() {\n    if (contentSize <= viewSize) return [scrollBounds.max];\n    if (containScroll === 'keepSnaps') return snapsBounded;\n    var _a = findDuplicates(),\n      min = _a.min,\n      max = _a.max;\n    return snapsBounded.slice(min, max);\n  }\n  var self = {\n    snapsContained: snapsContained\n  };\n  return self;\n}\nfunction ScrollLimit(contentSize, scrollSnaps, loop) {\n  var limit = measureLimit();\n  function measureLimit() {\n    var startSnap = scrollSnaps[0];\n    var endSnap = arrayLast(scrollSnaps);\n    var min = loop ? startSnap - contentSize : endSnap;\n    var max = startSnap;\n    return Limit(min, max);\n  }\n  var self = {\n    limit: limit\n  };\n  return self;\n}\nfunction ScrollLooper(contentSize, pxToPercent, limit, location, vectors) {\n  var min = limit.min + pxToPercent.measure(0.1);\n  var max = limit.max + pxToPercent.measure(0.1);\n  var _a = Limit(min, max),\n    reachedMin = _a.reachedMin,\n    reachedMax = _a.reachedMax;\n  function shouldLoop(direction) {\n    if (direction === 1) return reachedMax(location.get());\n    if (direction === -1) return reachedMin(location.get());\n    return false;\n  }\n  function loop(direction) {\n    if (!shouldLoop(direction)) return;\n    var loopDistance = contentSize * (direction * -1);\n    vectors.forEach(function (v) {\n      return v.add(loopDistance);\n    });\n  }\n  var self = {\n    loop: loop\n  };\n  return self;\n}\nfunction ScrollProgress(limit) {\n  var max = limit.max,\n    scrollLength = limit.length;\n  function get(n) {\n    var currentLocation = n - max;\n    return currentLocation / -scrollLength;\n  }\n  var self = {\n    get: get\n  };\n  return self;\n}\nfunction ScrollSnap(axis, alignment, pxToPercent, containerRect, slideRects, slidesToScroll) {\n  var startEdge = axis.startEdge,\n    endEdge = axis.endEdge;\n  var snaps = measureUnaligned();\n  var snapsAligned = measureAligned();\n  function measureSizes() {\n    return groupArray(slideRects, slidesToScroll).map(function (rects) {\n      return arrayLast(rects)[endEdge] - rects[0][startEdge];\n    }).map(pxToPercent.measure).map(Math.abs);\n  }\n  function measureUnaligned() {\n    return slideRects.map(function (rect) {\n      return containerRect[startEdge] - rect[startEdge];\n    }).map(pxToPercent.measure).map(function (snap) {\n      return -Math.abs(snap);\n    });\n  }\n  function measureAligned() {\n    var groupedSnaps = groupArray(snaps, slidesToScroll).map(function (g) {\n      return g[0];\n    });\n    var alignments = measureSizes().map(alignment.measure);\n    return groupedSnaps.map(function (snap, index) {\n      return snap + alignments[index];\n    });\n  }\n  var self = {\n    snaps: snaps,\n    snapsAligned: snapsAligned\n  };\n  return self;\n}\nfunction ScrollTarget(loop, scrollSnaps, contentSize, limit, targetVector) {\n  var reachedAny = limit.reachedAny,\n    removeOffset = limit.removeOffset,\n    constrain = limit.constrain;\n  function minDistance(d1, d2) {\n    return Math.abs(d1) < Math.abs(d2) ? d1 : d2;\n  }\n  function findTargetSnap(target) {\n    var distance = loop ? removeOffset(target) : constrain(target);\n    var ascDiffsToSnaps = scrollSnaps.map(function (scrollSnap) {\n      return scrollSnap - distance;\n    }).map(function (diffToSnap) {\n      return shortcut(diffToSnap, 0);\n    }).map(function (diff, i) {\n      return {\n        diff: diff,\n        index: i\n      };\n    }).sort(function (d1, d2) {\n      return Math.abs(d1.diff) - Math.abs(d2.diff);\n    });\n    var index = ascDiffsToSnaps[0].index;\n    return {\n      index: index,\n      distance: distance\n    };\n  }\n  function shortcut(target, direction) {\n    var t1 = target;\n    var t2 = target + contentSize;\n    var t3 = target - contentSize;\n    if (!loop) return t1;\n    if (!direction) return minDistance(minDistance(t1, t2), t3);\n    var shortest = minDistance(t1, direction === 1 ? t2 : t3);\n    return Math.abs(shortest) * direction;\n  }\n  function byIndex(index, direction) {\n    var diffToSnap = scrollSnaps[index] - targetVector.get();\n    var distance = shortcut(diffToSnap, direction);\n    return {\n      index: index,\n      distance: distance\n    };\n  }\n  function byDistance(distance, snap) {\n    var target = targetVector.get() + distance;\n    var _a = findTargetSnap(target),\n      index = _a.index,\n      targetSnapDistance = _a.distance;\n    var reachedBound = !loop && reachedAny(target);\n    if (!snap || reachedBound) return {\n      index: index,\n      distance: distance\n    };\n    var diffToSnap = scrollSnaps[index] - targetSnapDistance;\n    var snapDistance = distance + shortcut(diffToSnap, 0);\n    return {\n      index: index,\n      distance: snapDistance\n    };\n  }\n  var self = {\n    byDistance: byDistance,\n    byIndex: byIndex,\n    shortcut: shortcut\n  };\n  return self;\n}\nfunction ScrollTo(animation, indexCurrent, indexPrevious, scrollTarget, targetVector, events) {\n  function scrollTo(target) {\n    var distanceDiff = target.distance;\n    var indexDiff = target.index !== indexCurrent.get();\n    if (distanceDiff) {\n      animation.start();\n      targetVector.add(distanceDiff);\n    }\n    if (indexDiff) {\n      indexPrevious.set(indexCurrent.get());\n      indexCurrent.set(target.index);\n      events.emit('select');\n    }\n  }\n  function distance(n, snap) {\n    var target = scrollTarget.byDistance(n, snap);\n    scrollTo(target);\n  }\n  function index(n, direction) {\n    var targetIndex = indexCurrent.clone().set(n);\n    var target = scrollTarget.byIndex(targetIndex.get(), direction);\n    scrollTo(target);\n  }\n  var self = {\n    distance: distance,\n    index: index\n  };\n  return self;\n}\nfunction SlideLooper(axis, viewSize, contentSize, slideSizesWithGaps, scrollSnaps, slidesInView, scrollLocation, slides) {\n  var ascItems = arrayKeys(slideSizesWithGaps);\n  var descItems = arrayKeys(slideSizesWithGaps).reverse();\n  var loopPoints = startPoints().concat(endPoints());\n  function removeSlideSizes(indexes, from) {\n    return indexes.reduce(function (a, i) {\n      return a - slideSizesWithGaps[i];\n    }, from);\n  }\n  function slidesInGap(indexes, gap) {\n    return indexes.reduce(function (a, i) {\n      var remainingGap = removeSlideSizes(a, gap);\n      return remainingGap > 0 ? a.concat([i]) : a;\n    }, []);\n  }\n  function findLoopPoints(indexes, edge) {\n    var isStartEdge = edge === 'start';\n    var offset = isStartEdge ? -contentSize : contentSize;\n    var slideBounds = slidesInView.findSlideBounds(offset);\n    return indexes.map(function (index) {\n      var initial = isStartEdge ? 0 : -contentSize;\n      var altered = isStartEdge ? contentSize : 0;\n      var bounds = slideBounds.filter(function (b) {\n        return b.index === index;\n      })[0];\n      var point = bounds[isStartEdge ? 'end' : 'start'];\n      var getTarget = function getTarget() {\n        return scrollLocation.get() > point ? initial : altered;\n      };\n      return {\n        point: point,\n        getTarget: getTarget,\n        index: index,\n        location: -1\n      };\n    });\n  }\n  function startPoints() {\n    var gap = scrollSnaps[0] - 1;\n    var indexes = slidesInGap(descItems, gap);\n    return findLoopPoints(indexes, 'end');\n  }\n  function endPoints() {\n    var gap = viewSize - scrollSnaps[0] - 1;\n    var indexes = slidesInGap(ascItems, gap);\n    return findLoopPoints(indexes, 'start');\n  }\n  function canLoop() {\n    return loopPoints.every(function (_a) {\n      var index = _a.index;\n      var otherIndexes = ascItems.filter(function (i) {\n        return i !== index;\n      });\n      return removeSlideSizes(otherIndexes, viewSize) <= 0;\n    });\n  }\n  function loop() {\n    loopPoints.forEach(function (loopPoint) {\n      var getTarget = loopPoint.getTarget,\n        location = loopPoint.location,\n        index = loopPoint.index;\n      var target = getTarget();\n      if (target !== location) {\n        slides[index].style[axis.startEdge] = target + \"%\";\n        loopPoint.location = target;\n      }\n    });\n  }\n  function clear() {\n    loopPoints.forEach(function (_a) {\n      var index = _a.index;\n      slides[index].style[axis.startEdge] = '';\n    });\n  }\n  var self = {\n    canLoop: canLoop,\n    clear: clear,\n    loop: loop,\n    loopPoints: loopPoints\n  };\n  return self;\n}\nfunction SlideFocus(rootNode, scrollTo, slidesToScroll) {\n  var eventStore = EventStore();\n  var removeAllEvents = eventStore.removeAll;\n  var lastTabPressTime = 0;\n  function registerTabPress(event) {\n    if (event.keyCode !== 9) return;\n    lastTabPressTime = new Date().getTime();\n  }\n  function addFocusEvent(slide, index) {\n    var focus = function focus() {\n      var nowTime = new Date().getTime();\n      var diffTime = nowTime - lastTabPressTime;\n      if (diffTime > 10) return;\n      rootNode.scrollLeft = 0;\n      var selectedIndex = Math.floor(index / slidesToScroll);\n      scrollTo.index(selectedIndex, 0);\n    };\n    eventStore.add(slide, 'focus', focus, true);\n  }\n  function addActivationEvents(slides) {\n    eventStore.add(document, 'keydown', registerTabPress, false);\n    slides.forEach(addFocusEvent);\n  }\n  var self = {\n    addActivationEvents: addActivationEvents,\n    removeAllEvents: removeAllEvents\n  };\n  return self;\n}\nfunction SlidesInView(viewSize, contentSize, slideSizes, snaps, loop, inViewThreshold) {\n  var threshold = Math.min(Math.max(inViewThreshold, 0.01), 0.99);\n  var offsets = loop ? [0, contentSize, -contentSize] : [0];\n  var slideBounds = offsets.reduce(function (a, offset) {\n    return a.concat(findSlideBounds(offset, threshold));\n  }, []);\n  function findSlideBounds(offset, threshold) {\n    var thresholds = slideSizes.map(function (s) {\n      return s * (threshold || 0);\n    });\n    return snaps.map(function (snap, index) {\n      return {\n        start: snap - slideSizes[index] + thresholds[index] + offset,\n        end: snap + viewSize - thresholds[index] + offset,\n        index: index\n      };\n    });\n  }\n  function check(location) {\n    return slideBounds.reduce(function (list, slideBound) {\n      var index = slideBound.index,\n        start = slideBound.start,\n        end = slideBound.end;\n      var inList = list.indexOf(index) !== -1;\n      var inView = start < location && end > location;\n      return !inList && inView ? list.concat([index]) : list;\n    }, []);\n  }\n  var self = {\n    check: check,\n    findSlideBounds: findSlideBounds\n  };\n  return self;\n}\nfunction SlideSizes(axis, pxToPercent, slides, slideRects, loop) {\n  var measureSize = axis.measureSize,\n    startEdge = axis.startEdge,\n    endEdge = axis.endEdge;\n  var sizesInPx = slideRects.map(measureSize);\n  var slideSizes = sizesInPx.map(pxToPercent.measure);\n  var slideSizesWithGaps = measureWithGaps();\n  function measureWithGaps() {\n    return slideRects.map(function (rect, index, rects) {\n      var isLast = index === lastIndex(rects);\n      var style = window.getComputedStyle(arrayLast(slides));\n      var endGap = parseFloat(style.getPropertyValue(\"margin-\" + endEdge));\n      if (isLast) return sizesInPx[index] + (loop ? endGap : 0);\n      return rects[index + 1][startEdge] - rect[startEdge];\n    }).map(pxToPercent.measure).map(Math.abs);\n  }\n  var self = {\n    slideSizes: slideSizes,\n    slideSizesWithGaps: slideSizesWithGaps\n  };\n  return self;\n}\nfunction Translate(axis, direction, container) {\n  var containerStyle = container.style;\n  var translate = axis.scroll === 'x' ? x : y;\n  var disabled = false;\n  function x(n) {\n    return \"translate3d(\" + n + \"%,0px,0px)\";\n  }\n  function y(n) {\n    return \"translate3d(0px,\" + n + \"%,0px)\";\n  }\n  function to(target) {\n    if (disabled) return;\n    containerStyle.transform = translate(direction.applyTo(target.get()));\n  }\n  function toggleActive(active) {\n    disabled = !active;\n  }\n  function clear() {\n    containerStyle.transform = '';\n  }\n  var self = {\n    clear: clear,\n    to: to,\n    toggleActive: toggleActive\n  };\n  return self;\n}\nfunction Engine(root, container, slides, options, events) {\n  // Options\n  var align = options.align,\n    scrollAxis = options.axis,\n    contentDirection = options.direction,\n    startIndex = options.startIndex,\n    inViewThreshold = options.inViewThreshold,\n    loop = options.loop,\n    speed = options.speed,\n    dragFree = options.dragFree,\n    slidesToScroll = options.slidesToScroll,\n    skipSnaps = options.skipSnaps,\n    containScroll = options.containScroll; // Measurements\n\n  var containerRect = container.getBoundingClientRect();\n  var slideRects = slides.map(function (slide) {\n    return slide.getBoundingClientRect();\n  });\n  var direction = Direction(contentDirection);\n  var axis = Axis(scrollAxis, contentDirection);\n  var pxToPercent = PxToPercent(axis.measureSize(containerRect));\n  var viewSize = pxToPercent.totalPercent;\n  var alignment = Alignment(align, viewSize);\n  var _a = SlideSizes(axis, pxToPercent, slides, slideRects, loop),\n    slideSizes = _a.slideSizes,\n    slideSizesWithGaps = _a.slideSizesWithGaps;\n  var _b = ScrollSnap(axis, alignment, pxToPercent, containerRect, slideRects, slidesToScroll),\n    snaps = _b.snaps,\n    snapsAligned = _b.snapsAligned;\n  var contentSize = -arrayLast(snaps) + arrayLast(slideSizesWithGaps);\n  var snapsContained = ScrollContain(viewSize, contentSize, snaps, snapsAligned, containScroll).snapsContained;\n  var contain = !loop && containScroll !== '';\n  var scrollSnaps = contain ? snapsContained : snapsAligned;\n  var limit = ScrollLimit(contentSize, scrollSnaps, loop).limit; // Indexes\n\n  var index = Counter(lastIndex(scrollSnaps), startIndex, loop);\n  var indexPrevious = index.clone();\n  var slideIndexes = arrayKeys(slides); // Draw\n\n  var update = function update() {\n    if (!loop) engine.scrollBounds.constrain(engine.dragHandler.pointerDown());\n    engine.scrollBody.seek(target).update();\n    var settled = engine.scrollBody.settle(target);\n    if (settled && !engine.dragHandler.pointerDown()) {\n      engine.animation.stop();\n      events.emit('settle');\n    }\n    if (!settled) {\n      events.emit('scroll');\n    }\n    if (loop) {\n      engine.scrollLooper.loop(engine.scrollBody.direction());\n      engine.slideLooper.loop();\n    }\n    engine.translate.to(location);\n    engine.animation.proceed();\n  }; // Shared\n\n  var animation = Animation(update);\n  var startLocation = scrollSnaps[index.get()];\n  var location = Vector1D(startLocation);\n  var target = Vector1D(startLocation);\n  var scrollBody = ScrollBody(location, speed, 1);\n  var scrollTarget = ScrollTarget(loop, scrollSnaps, contentSize, limit, target);\n  var scrollTo = ScrollTo(animation, index, indexPrevious, scrollTarget, target, events);\n  var slidesInView = SlidesInView(viewSize, contentSize, slideSizes, snaps, loop, inViewThreshold); // DragHandler\n\n  var dragHandler = DragHandler(axis, direction, root, target, dragFree, DragTracker(axis, pxToPercent), location, animation, scrollTo, scrollBody, scrollTarget, index, events, loop, skipSnaps); // Slider\n\n  var engine = {\n    animation: animation,\n    axis: axis,\n    direction: direction,\n    dragHandler: dragHandler,\n    pxToPercent: pxToPercent,\n    index: index,\n    indexPrevious: indexPrevious,\n    limit: limit,\n    location: location,\n    options: options,\n    scrollBody: scrollBody,\n    scrollBounds: ScrollBounds(limit, location, target, scrollBody),\n    scrollLooper: ScrollLooper(contentSize, pxToPercent, limit, location, [location, target]),\n    scrollProgress: ScrollProgress(limit),\n    scrollSnaps: scrollSnaps,\n    scrollTarget: scrollTarget,\n    scrollTo: scrollTo,\n    slideFocus: SlideFocus(root, scrollTo, slidesToScroll),\n    slideLooper: SlideLooper(axis, viewSize, contentSize, slideSizesWithGaps, scrollSnaps, slidesInView, location, slides),\n    slidesInView: slidesInView,\n    slideIndexes: slideIndexes,\n    target: target,\n    translate: Translate(axis, direction, container)\n  };\n  return engine;\n}\nfunction EventEmitter() {\n  var listeners = {};\n  function getListeners(evt) {\n    var eventListeners = listeners[evt];\n    return eventListeners || [];\n  }\n  function emit(evt) {\n    getListeners(evt).forEach(function (e) {\n      return e(evt);\n    });\n    return self;\n  }\n  function on(evt, cb) {\n    listeners[evt] = getListeners(evt).concat([cb]);\n    return self;\n  }\n  function off(evt, cb) {\n    listeners[evt] = getListeners(evt).filter(function (e) {\n      return e !== cb;\n    });\n    return self;\n  }\n  var self = {\n    emit: emit,\n    off: off,\n    on: on\n  };\n  return self;\n}\nvar defaultOptions = {\n  align: 'center',\n  axis: 'x',\n  containScroll: '',\n  direction: 'ltr',\n  dragFree: false,\n  draggable: true,\n  draggableClass: 'is-draggable',\n  draggingClass: 'is-dragging',\n  inViewThreshold: 0,\n  loop: false,\n  skipSnaps: true,\n  selectedClass: 'is-selected',\n  slidesToScroll: 1,\n  speed: 10,\n  startIndex: 0\n};\nfunction OptionsPseudo(node) {\n  var pseudoString = getComputedStyle(node, ':before').content;\n  function get() {\n    try {\n      return JSON.parse(pseudoString.slice(1, -1).replace(/\\\\/g, ''));\n    } catch (error) {} // eslint-disable-line no-empty\n\n    return {};\n  }\n  var self = {\n    get: get\n  };\n  return self;\n}\nfunction EmblaCarousel(sliderRoot, userOptions) {\n  var events = EventEmitter();\n  var eventStore = EventStore();\n  var debouncedResize = debounce(resize, 500);\n  var reInit = reActivate;\n  var on = events.on,\n    off = events.off;\n  var engine;\n  var activated = false;\n  var optionsBase = _extends({}, defaultOptions);\n  var options = _extends({}, optionsBase);\n  var optionsPseudo;\n  var rootNodeSize = 0;\n  var container;\n  var slides;\n  activate(userOptions);\n  function setupElements() {\n    if (!sliderRoot) throw new Error('Missing root node 😢');\n    var sliderContainer = sliderRoot.querySelector('*');\n    if (!sliderContainer) throw new Error('Missing container node 😢');\n    container = sliderContainer;\n    slides = Array.prototype.slice.call(container.children);\n    optionsPseudo = OptionsPseudo(sliderRoot);\n  }\n  function activate(partialOptions) {\n    setupElements();\n    optionsBase = _extends({}, optionsBase, partialOptions);\n    options = _extends({}, optionsBase, optionsPseudo.get());\n    engine = Engine(sliderRoot, container, slides, options, events);\n    eventStore.add(window, 'resize', debouncedResize);\n    engine.translate.to(engine.location);\n    rootNodeSize = engine.axis.measureSize(sliderRoot.getBoundingClientRect());\n    if (options.loop) {\n      if (!engine.slideLooper.canLoop()) {\n        deActivate();\n        return activate({\n          loop: false\n        });\n      }\n      engine.slideLooper.loop();\n    }\n    if (options.draggable && container.offsetParent && slides.length) {\n      engine.dragHandler.addActivationEvents();\n      if (options.draggableClass) {\n        addClass(sliderRoot, options.draggableClass);\n      }\n      if (options.draggingClass) {\n        events.on('pointerDown', toggleDraggingClass).on('pointerUp', toggleDraggingClass);\n      }\n    }\n    if (slides.length) {\n      engine.slideFocus.addActivationEvents(slides);\n    }\n    if (options.selectedClass) {\n      toggleSelectedClass();\n      events.on('select', toggleSelectedClass).on('pointerUp', toggleSelectedClass);\n    }\n    if (!activated) {\n      setTimeout(function () {\n        return events.emit('init');\n      }, 0);\n      activated = true;\n    }\n  }\n  function toggleDraggingClass(evt) {\n    var draggingClass = options.draggingClass;\n    if (evt === 'pointerDown') addClass(sliderRoot, draggingClass);else removeClass(sliderRoot, draggingClass);\n  }\n  function toggleSelectedClass() {\n    var selectedClass = options.selectedClass;\n    var inView = slidesInView(true);\n    var notInView = slidesNotInView(true);\n    notInView.forEach(function (index) {\n      return removeClass(slides[index], selectedClass);\n    });\n    inView.forEach(function (index) {\n      return addClass(slides[index], selectedClass);\n    });\n  }\n  function deActivate() {\n    engine.dragHandler.removeAllEvents();\n    engine.slideFocus.removeAllEvents();\n    engine.animation.stop();\n    eventStore.removeAll();\n    engine.translate.clear();\n    engine.slideLooper.clear();\n    removeClass(sliderRoot, options.draggableClass);\n    slides.forEach(function (slide) {\n      return removeClass(slide, options.selectedClass);\n    });\n    events.off('select', toggleSelectedClass).off('pointerUp', toggleSelectedClass).off('pointerDown', toggleDraggingClass).off('pointerUp', toggleDraggingClass);\n  }\n  function reActivate(partialOptions) {\n    if (!activated) return;\n    var startIndex = selectedScrollSnap();\n    var newOptions = _extends({\n      startIndex: startIndex\n    }, partialOptions);\n    deActivate();\n    activate(newOptions);\n    events.emit('reInit');\n  }\n  function destroy() {\n    if (!activated) return;\n    deActivate();\n    activated = false;\n    events.emit('destroy');\n  }\n  function resize() {\n    if (!activated) return;\n    var size = engine.axis.measureSize(sliderRoot.getBoundingClientRect());\n    if (rootNodeSize !== size) reActivate();\n    events.emit('resize');\n  }\n  function slidesInView(target) {\n    var location = engine[target ? 'target' : 'location'].get();\n    var type = options.loop ? 'removeOffset' : 'constrain';\n    return engine.slidesInView.check(engine.limit[type](location));\n  }\n  function slidesNotInView(target) {\n    var inView = slidesInView(target);\n    return engine.slideIndexes.filter(function (index) {\n      return inView.indexOf(index) === -1;\n    });\n  }\n  function scrollTo(index, jump, direction) {\n    engine.scrollBody.useBaseMass().useSpeed(jump ? 100 : options.speed);\n    if (activated) engine.scrollTo.index(index, direction || 0);\n  }\n  function scrollNext(jump) {\n    var next = engine.index.clone().add(1);\n    scrollTo(next.get(), jump === true, -1);\n  }\n  function scrollPrev(jump) {\n    var prev = engine.index.clone().add(-1);\n    scrollTo(prev.get(), jump === true, 1);\n  }\n  function canScrollNext() {\n    var next = engine.index.clone().add(1);\n    return next.get() !== selectedScrollSnap();\n  }\n  function canScrollPrev() {\n    var prev = engine.index.clone().add(-1);\n    return prev.get() !== selectedScrollSnap();\n  }\n  function scrollSnapList() {\n    return engine.scrollSnaps.map(engine.scrollProgress.get);\n  }\n  function scrollProgress() {\n    return engine.scrollProgress.get(engine.location.get());\n  }\n  function selectedScrollSnap() {\n    return engine.index.get();\n  }\n  function previousScrollSnap() {\n    return engine.indexPrevious.get();\n  }\n  function clickAllowed() {\n    return engine.dragHandler.clickAllowed();\n  }\n  function dangerouslyGetEngine() {\n    return engine;\n  }\n  function rootNode() {\n    return sliderRoot;\n  }\n  function containerNode() {\n    return container;\n  }\n  function slideNodes() {\n    return slides;\n  }\n  var self = {\n    canScrollNext: canScrollNext,\n    canScrollPrev: canScrollPrev,\n    clickAllowed: clickAllowed,\n    containerNode: containerNode,\n    dangerouslyGetEngine: dangerouslyGetEngine,\n    destroy: destroy,\n    off: off,\n    on: on,\n    previousScrollSnap: previousScrollSnap,\n    reInit: reInit,\n    rootNode: rootNode,\n    scrollNext: scrollNext,\n    scrollPrev: scrollPrev,\n    scrollProgress: scrollProgress,\n    scrollSnapList: scrollSnapList,\n    scrollTo: scrollTo,\n    selectedScrollSnap: selectedScrollSnap,\n    slideNodes: slideNodes,\n    slidesInView: slidesInView,\n    slidesNotInView: slidesNotInView\n  };\n  return self;\n}\nfunction canUseDOM() {\n  return !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n}\nfunction areEqualShallow(objectA, objectB) {\n  return Object.keys(objectA).length === Object.keys(objectB).length && Object.keys(objectA).every(function (objectKey) {\n    if (!Object.prototype.hasOwnProperty.call(objectB, objectKey)) {\n      return false;\n    }\n    return objectA[objectKey] === objectB[objectKey];\n  });\n}\nfunction useEmblaCarousel(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var _a = react.useState(),\n    embla = _a[0],\n    setEmbla = _a[1];\n  var _b = react.useState(),\n    viewport = _b[0],\n    setViewport = _b[1];\n  var storedOptions = react.useRef(options);\n  var activeOptions = react.useMemo(function () {\n    if (!areEqualShallow(storedOptions.current, options)) {\n      storedOptions.current = options;\n    }\n    return storedOptions.current;\n  }, [storedOptions, options]);\n  react.useEffect(function () {\n    if (canUseDOM() && viewport) {\n      var newEmbla_1 = EmblaCarousel(viewport, activeOptions);\n      setEmbla(newEmbla_1);\n      return function () {\n        return newEmbla_1.destroy();\n      };\n    } else {\n      setEmbla(undefined);\n    }\n  }, [viewport, activeOptions, setEmbla]);\n  return [setViewport, embla];\n}\nexports.useEmblaCarousel = useEmblaCarousel;","map":{"version":3,"mappings":"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","names":["Alignment","align","viewSize","predefined","start","center","end","n","percent","Number","measure","self","Animation","callback","animationFrame","ifAnimating","active","cb","window","requestAnimationFrame","stop","cancelAnimationFrame","proceed","Axis","axis","contentDirection","scroll","cross","startEdge","getStartEdge","endEdge","getEndEdge","measureSize","rect","height","width","Limit","min","max","length","Math","abs","reachedMin","reachedMax","reachedAny","constrain","removeOffset","ceil","Counter","loop","loopEnd","counter","withinLimit","get","set","add","clone","Direction","direction","sign","applyTo","EventStore","listeners","node","type","handler","options","addEventListener","push","removeEventListener","removeAll","filter","remove","Vector1D","value","vector","readNumber","subtract","multiply","divide","normalize","map","iStart","iStop","oStart","oStop","mathSign","deltaAbs","valueB","valueA","factorAbs","diff","roundToDecimals","decimalPoints","pow","round","debounce","time","timeout","clearTimeout","setTimeout","groupArray","array","size","groups","i","slice","arrayKeys","Object","keys","arrayLast","lastIndex","removeClass","className","cl","classList","contains","addClass","DragHandler","rootNode","target","dragFree","dragTracker","location","animation","scrollTo","scrollBody","scrollTarget","index","events","skipSnaps","scrollAxis","crossAxis","focusNodes","startScroll","startCross","dragStartPoint","activationEvents","interactionEvents","snapForceBoost","mouse","touch","freeForceBoost","baseSpeed","baseMass","dragThreshold","pointerIsDown","preventScroll","preventClick","isMouse","addActivationEvents","down","up","click","addInteractionEvents","document","move","removeAllEvents","isFocusNode","name","nodeName","indexOf","forceBoost","boost","allowedForce","force","targetChanged","next","isEdge","baseForce","byDistance","distance","byIndex","evt","button","isMoving","clearPreventClick","isNotFocusNode","preventDefault","pointerDown","useBaseMass","useSpeed","readPoint","emit","cancelable","moveScroll","moveCross","diffScroll","diffCross","pointerMove","currentLocation","rawForce","pointerUp","forceFactor","isVigorous","isBelowThreshold","speed","mass","useMass","clickAllowed","DragTracker","pxToPercent","coords","x","y","startDrag","diffDrag","lastDrag","pointValue","trackInterval","trackLength","trackTime","trackPoints","lastMoveTime","Date","getTime","touches","c","point","nowTime","diffTime","currentPoint","trackPoint","sort","p1","p2","PxToPercent","viewInPx","totalPercent","ScrollBody","roundToTwoDecimals","velocity","acceleration","attraction","attractionDirection","update","applyForce","v","seek","magnitude","settle","hasSettled","useBaseSpeed","ScrollBounds","limit","pullBackThreshold","disabled","shouldConstrain","friction","diffToTarget","toggleActive","ScrollContain","contentSize","snaps","snapsAligned","containScroll","scrollBounds","snapsBounded","snapsContained","measureContained","findDuplicates","startSnap","endSnap","lastIndexOf","ScrollLimit","scrollSnaps","measureLimit","ScrollLooper","vectors","shouldLoop","loopDistance","forEach","ScrollProgress","scrollLength","ScrollSnap","alignment","containerRect","slideRects","slidesToScroll","measureUnaligned","measureAligned","measureSizes","rects","snap","groupedSnaps","g","alignments","ScrollTarget","targetVector","minDistance","d1","d2","findTargetSnap","ascDiffsToSnaps","scrollSnap","diffToSnap","shortcut","t1","t2","t3","shortest","targetSnapDistance","reachedBound","snapDistance","ScrollTo","indexCurrent","indexPrevious","distanceDiff","indexDiff","targetIndex","SlideLooper","slideSizesWithGaps","slidesInView","scrollLocation","slides","ascItems","descItems","reverse","loopPoints","startPoints","concat","endPoints","removeSlideSizes","indexes","from","reduce","a","slidesInGap","gap","remainingGap","findLoopPoints","edge","isStartEdge","offset","slideBounds","findSlideBounds","initial","altered","bounds","b","getTarget","canLoop","every","_a","otherIndexes","loopPoint","style","clear","SlideFocus","eventStore","lastTabPressTime","registerTabPress","event","keyCode","addFocusEvent","slide","focus","scrollLeft","selectedIndex","floor","SlidesInView","slideSizes","inViewThreshold","threshold","offsets","thresholds","s","check","list","slideBound","inList","inView","SlideSizes","sizesInPx","measureWithGaps","isLast","getComputedStyle","endGap","parseFloat","getPropertyValue","Translate","container","containerStyle","translate","to","transform","Engine","root","startIndex","getBoundingClientRect","contain","slideIndexes","engine","dragHandler","settled","scrollLooper","slideLooper","startLocation","scrollProgress","slideFocus","EventEmitter","getListeners","eventListeners","e","on","off","defaultOptions","draggable","draggableClass","draggingClass","selectedClass","OptionsPseudo","pseudoString","content","JSON","parse","replace","error","EmblaCarousel","sliderRoot","userOptions","debouncedResize","resize","reInit","reActivate","activated","optionsBase","_extends","optionsPseudo","rootNodeSize","activate","setupElements","Error","sliderContainer","querySelector","Array","prototype","call","children","partialOptions","deActivate","offsetParent","toggleDraggingClass","toggleSelectedClass","notInView","slidesNotInView","selectedScrollSnap","newOptions","destroy","jump","scrollNext","scrollPrev","prev","canScrollNext","canScrollPrev","scrollSnapList","previousScrollSnap","dangerouslyGetEngine","containerNode","slideNodes","canUseDOM","createElement","areEqualShallow","objectA","objectB","objectKey","hasOwnProperty","useEmblaCarousel","useState","embla","setEmbla","viewport","setViewport","storedOptions","useRef","activeOptions","useMemo","current","useEffect","newEmbla_1","undefined"],"sources":["C:\\Users\\HP\\Desktop\\new try\\Official Website 2k23\\node_modules\\embla-carousel\\src\\embla-carousel-vanilla\\alignment.ts","C:\\Users\\HP\\Desktop\\new try\\Official Website 2k23\\node_modules\\embla-carousel\\src\\embla-carousel-vanilla\\animation.ts","C:\\Users\\HP\\Desktop\\new try\\Official Website 2k23\\node_modules\\embla-carousel\\src\\embla-carousel-vanilla\\axis.ts","C:\\Users\\HP\\Desktop\\new try\\Official Website 2k23\\node_modules\\embla-carousel\\src\\embla-carousel-vanilla\\limit.ts","C:\\Users\\HP\\Desktop\\new try\\Official Website 2k23\\node_modules\\embla-carousel\\src\\embla-carousel-vanilla\\counter.ts","C:\\Users\\HP\\Desktop\\new try\\Official Website 2k23\\node_modules\\embla-carousel\\src\\embla-carousel-vanilla\\direction.ts","C:\\Users\\HP\\Desktop\\new try\\Official Website 2k23\\node_modules\\embla-carousel\\src\\embla-carousel-vanilla\\eventStore.ts","C:\\Users\\HP\\Desktop\\new try\\Official Website 2k23\\node_modules\\embla-carousel\\src\\embla-carousel-vanilla\\vector1d.ts","C:\\Users\\HP\\Desktop\\new try\\Official Website 2k23\\node_modules\\embla-carousel\\src\\embla-carousel-vanilla\\utils.ts","C:\\Users\\HP\\Desktop\\new try\\Official Website 2k23\\node_modules\\embla-carousel\\src\\embla-carousel-vanilla\\dragHandler.ts","C:\\Users\\HP\\Desktop\\new try\\Official Website 2k23\\node_modules\\embla-carousel\\src\\embla-carousel-vanilla\\dragTracker.ts","C:\\Users\\HP\\Desktop\\new try\\Official Website 2k23\\node_modules\\embla-carousel\\src\\embla-carousel-vanilla\\pxToPercent.ts","C:\\Users\\HP\\Desktop\\new try\\Official Website 2k23\\node_modules\\embla-carousel\\src\\embla-carousel-vanilla\\scrollBody.ts","C:\\Users\\HP\\Desktop\\new try\\Official Website 2k23\\node_modules\\embla-carousel\\src\\embla-carousel-vanilla\\scrollBounds.ts","C:\\Users\\HP\\Desktop\\new try\\Official Website 2k23\\node_modules\\embla-carousel\\src\\embla-carousel-vanilla\\scrollContain.ts","C:\\Users\\HP\\Desktop\\new try\\Official Website 2k23\\node_modules\\embla-carousel\\src\\embla-carousel-vanilla\\scrollLimit.ts","C:\\Users\\HP\\Desktop\\new try\\Official Website 2k23\\node_modules\\embla-carousel\\src\\embla-carousel-vanilla\\scrollLooper.ts","C:\\Users\\HP\\Desktop\\new try\\Official Website 2k23\\node_modules\\embla-carousel\\src\\embla-carousel-vanilla\\scrollProgress.ts","C:\\Users\\HP\\Desktop\\new try\\Official Website 2k23\\node_modules\\embla-carousel\\src\\embla-carousel-vanilla\\scrollSnap.ts","C:\\Users\\HP\\Desktop\\new try\\Official Website 2k23\\node_modules\\embla-carousel\\src\\embla-carousel-vanilla\\scrollTarget.ts","C:\\Users\\HP\\Desktop\\new try\\Official Website 2k23\\node_modules\\embla-carousel\\src\\embla-carousel-vanilla\\scrollTo.ts","C:\\Users\\HP\\Desktop\\new try\\Official Website 2k23\\node_modules\\embla-carousel\\src\\embla-carousel-vanilla\\slideLooper.ts","C:\\Users\\HP\\Desktop\\new try\\Official Website 2k23\\node_modules\\embla-carousel\\src\\embla-carousel-vanilla\\slideFocus.ts","C:\\Users\\HP\\Desktop\\new try\\Official Website 2k23\\node_modules\\embla-carousel\\src\\embla-carousel-vanilla\\slidesInView.ts","C:\\Users\\HP\\Desktop\\new try\\Official Website 2k23\\node_modules\\embla-carousel\\src\\embla-carousel-vanilla\\slideSizes.ts","C:\\Users\\HP\\Desktop\\new try\\Official Website 2k23\\node_modules\\embla-carousel\\src\\embla-carousel-vanilla\\translate.ts","C:\\Users\\HP\\Desktop\\new try\\Official Website 2k23\\node_modules\\embla-carousel\\src\\embla-carousel-vanilla\\engine.ts","C:\\Users\\HP\\Desktop\\new try\\Official Website 2k23\\node_modules\\embla-carousel\\src\\embla-carousel-vanilla\\eventEmitter.ts","C:\\Users\\HP\\Desktop\\new try\\Official Website 2k23\\node_modules\\embla-carousel\\src\\embla-carousel-vanilla\\options.ts","C:\\Users\\HP\\Desktop\\new try\\Official Website 2k23\\node_modules\\embla-carousel\\src\\embla-carousel-vanilla\\optionsPseudo.ts","C:\\Users\\HP\\Desktop\\new try\\Official Website 2k23\\node_modules\\embla-carousel\\src\\embla-carousel-vanilla\\index.ts","C:\\Users\\HP\\Desktop\\new try\\Official Website 2k23\\node_modules\\embla-carousel\\src\\embla-carousel-react\\utils.ts","C:\\Users\\HP\\Desktop\\new try\\Official Website 2k23\\node_modules\\embla-carousel\\src\\embla-carousel-react\\index.ts"],"sourcesContent":["export type AlignmentOptionType = 'start' | 'center' | 'end' | number\n\nexport type AlignmentType = {\n  measure: (n: number) => number\n}\n\nexport function Alignment(\n  align: AlignmentOptionType,\n  viewSize: number,\n): AlignmentType {\n  const predefined = { start, center, end }\n\n  function start(): number {\n    return 0\n  }\n\n  function center(n: number): number {\n    return end(n) / 2\n  }\n\n  function end(n: number): number {\n    return viewSize - n\n  }\n\n  function percent(): number {\n    return viewSize * Number(align)\n  }\n\n  function measure(n: number): number {\n    if (typeof align === 'number') return percent()\n    return predefined[align](n)\n  }\n\n  const self: AlignmentType = {\n    measure,\n  }\n  return self\n}\n","type CallbackType = () => void\n\nexport type AnimationType = {\n  start: () => void\n  stop: () => void\n  proceed: () => void\n}\n\nexport function Animation(callback: FrameRequestCallback): AnimationType {\n  let animationFrame = 0\n\n  function ifAnimating(active: boolean, cb: CallbackType): CallbackType {\n    return (): void => {\n      if (active === !!animationFrame) cb()\n    }\n  }\n\n  function start(): void {\n    animationFrame = window.requestAnimationFrame(callback)\n  }\n\n  function stop(): void {\n    window.cancelAnimationFrame(animationFrame)\n    animationFrame = 0\n  }\n\n  const self: AnimationType = {\n    proceed: ifAnimating(true, start),\n    start: ifAnimating(false, start),\n    stop: ifAnimating(true, stop),\n  }\n  return self\n}\n","import { DirectionOptionType } from './direction'\n\nexport type AxisOptionType = 'x' | 'y'\ntype AxisEdgeType = 'top' | 'right' | 'bottom' | 'left'\n\nexport type AxisType = {\n  scroll: AxisOptionType\n  cross: AxisOptionType\n  startEdge: AxisEdgeType\n  endEdge: AxisEdgeType\n  measureSize: (rect: DOMRect) => number\n}\n\nexport function Axis(\n  axis: AxisOptionType,\n  contentDirection: DirectionOptionType,\n): AxisType {\n  const scroll = axis === 'y' ? 'y' : 'x'\n  const cross = axis === 'y' ? 'x' : 'y'\n  const startEdge = getStartEdge()\n  const endEdge = getEndEdge()\n\n  function measureSize(rect: DOMRect): number {\n    const { width, height } = rect\n    return scroll === 'x' ? width : height\n  }\n\n  function getStartEdge(): AxisEdgeType {\n    if (scroll === 'y') return 'top'\n    return contentDirection === 'rtl' ? 'right' : 'left'\n  }\n\n  function getEndEdge(): AxisEdgeType {\n    if (scroll === 'y') return 'bottom'\n    return contentDirection === 'rtl' ? 'left' : 'right'\n  }\n\n  const self: AxisType = {\n    scroll,\n    cross,\n    startEdge,\n    endEdge,\n    measureSize,\n  }\n  return self\n}\n","export type LimitType = {\n  min: number\n  max: number\n  length: number\n  constrain: (n: number) => number\n  reachedAny: (n: number) => boolean\n  reachedMax: (n: number) => boolean\n  reachedMin: (n: number) => boolean\n  removeOffset: (n: number) => number\n}\n\nexport function Limit(min: number, max: number): LimitType {\n  const length = Math.abs(min - max)\n\n  function reachedMin(n: number): boolean {\n    return n < min\n  }\n\n  function reachedMax(n: number): boolean {\n    return n > max\n  }\n\n  function reachedAny(n: number): boolean {\n    return reachedMin(n) || reachedMax(n)\n  }\n\n  function constrain(n: number): number {\n    if (!reachedAny(n)) return n\n    return reachedMin(n) ? min : max\n  }\n\n  function removeOffset(n: number): number {\n    if (!length) return n\n    return n - length * Math.ceil((n - max) / length)\n  }\n\n  const self: LimitType = {\n    constrain,\n    length,\n    max,\n    min,\n    reachedAny,\n    reachedMax,\n    reachedMin,\n    removeOffset,\n  }\n  return self\n}\n","import { Limit } from './limit'\n\nexport type CounterType = {\n  get: () => number\n  set: (n: number) => CounterType\n  add: (n: number) => CounterType\n  clone: () => CounterType\n  min: number\n  max: number\n}\n\nexport function Counter(\n  max: number,\n  start: number,\n  loop: boolean,\n): CounterType {\n  const { min, constrain } = Limit(0, max)\n  const loopEnd = max + 1\n  let counter = withinLimit(start)\n\n  function withinLimit(n: number): number {\n    return !loop ? constrain(n) : Math.abs((loopEnd + n) % loopEnd)\n  }\n\n  function get(): number {\n    return counter\n  }\n\n  function set(n: number): CounterType {\n    counter = withinLimit(n)\n    return self\n  }\n\n  function add(n: number): CounterType {\n    return set(get() + n)\n  }\n\n  function clone(): CounterType {\n    return Counter(max, get(), loop)\n  }\n\n  const self: CounterType = {\n    add,\n    clone,\n    get,\n    set,\n    min,\n    max,\n  }\n  return self\n}\n","export type DirectionOptionType = 'ltr' | 'rtl'\n\nexport type DirectionType = {\n  applyTo: (n: number) => number\n}\n\nexport function Direction(direction: DirectionOptionType): DirectionType {\n  const sign = direction === 'rtl' ? -1 : 1\n\n  function applyTo(n: number): number {\n    return n * sign\n  }\n\n  const self: DirectionType = {\n    applyTo,\n  }\n  return self\n}\n","type EventRemoverType = () => void\ntype EventHandlerType = EventListener | EventListenerObject | null\ntype EventOptionsType = boolean | AddEventListenerOptions | undefined\n\nexport type EventStoreType = {\n  add: (\n    node: EventTarget,\n    type: keyof WindowEventMap,\n    handler: EventHandlerType,\n    options?: EventOptionsType,\n  ) => EventStoreType\n  removeAll: () => EventStoreType\n}\n\nexport function EventStore(): EventStoreType {\n  let listeners: EventRemoverType[] = []\n\n  function add(\n    node: EventTarget,\n    type: string,\n    handler: EventHandlerType,\n    options: EventOptionsType = false,\n  ): EventStoreType {\n    node.addEventListener(type, handler, options)\n    listeners.push(() => {\n      return node.removeEventListener(type, handler, options)\n    })\n    return self\n  }\n\n  function removeAll(): EventStoreType {\n    listeners = listeners.filter((remove) => remove())\n    return self\n  }\n\n  const self: EventStoreType = {\n    add,\n    removeAll,\n  }\n  return self\n}\n","export type Vector1DType = {\n  get: () => number\n  set: (v: Vector1DType | number) => Vector1DType\n  add: (v: Vector1DType | number) => Vector1DType\n  subtract: (v: Vector1DType | number) => Vector1DType\n  multiply: (n: number) => Vector1DType\n  divide: (n: number) => Vector1DType\n  normalize: () => Vector1DType\n}\n\nexport function Vector1D(value: number): Vector1DType {\n  let vector = value\n\n  function get(): number {\n    return vector\n  }\n\n  function set(n: Vector1DType | number): Vector1DType {\n    vector = readNumber(n)\n    return self\n  }\n\n  function add(n: Vector1DType | number): Vector1DType {\n    vector += readNumber(n)\n    return self\n  }\n\n  function subtract(n: Vector1DType | number): Vector1DType {\n    vector -= readNumber(n)\n    return self\n  }\n\n  function multiply(n: number): Vector1DType {\n    vector *= n\n    return self\n  }\n\n  function divide(n: number): Vector1DType {\n    vector /= n\n    return self\n  }\n\n  function normalize(): Vector1DType {\n    if (vector !== 0) divide(vector)\n    return self\n  }\n\n  function readNumber(n: Vector1DType | number): number {\n    return typeof n === 'number' ? n : n.get()\n  }\n\n  const self: Vector1DType = {\n    add,\n    divide,\n    get,\n    multiply,\n    normalize,\n    set,\n    subtract,\n  }\n  return self\n}\n","export function map(\n  value: number,\n  iStart: number,\n  iStop: number,\n  oStart: number,\n  oStop: number,\n): number {\n  return oStart + (oStop - oStart) * ((value - iStart) / (iStop - iStart))\n}\n\nexport function mathSign(n: number): number {\n  return !n ? 0 : n / Math.abs(n)\n}\n\nexport function deltaAbs(valueB: number, valueA: number): number {\n  return Math.abs(valueB - valueA)\n}\n\nexport function factorAbs(valueB: number, valueA: number): number {\n  if (valueB === 0 || valueA === 0) return 0\n  if (Math.abs(valueB) <= Math.abs(valueA)) return 0\n  const diff = deltaAbs(Math.abs(valueB), Math.abs(valueA))\n  return Math.abs(diff / valueB)\n}\n\nexport function roundToDecimals(decimalPoints: number): (n: number) => number {\n  const pow = Math.pow(10, decimalPoints)\n  return (n: number): number => Math.round(n * pow) / pow\n}\n\nexport function debounce(callback: () => void, time: number): () => void {\n  let timeout = 0\n  return (): void => {\n    window.clearTimeout(timeout)\n    timeout = window.setTimeout(callback, time) || 0\n  }\n}\n\nexport function groupArray<GenericType>(\n  array: GenericType[],\n  size: number,\n): GenericType[][] {\n  const groups = []\n  for (let i = 0; i < array.length; i += size) {\n    groups.push(array.slice(i, i + size))\n  }\n  return groups\n}\n\nexport function arrayKeys<GenericType>(array: GenericType[]): number[] {\n  return Object.keys(array).map(Number)\n}\n\nexport function arrayLast<GenericType>(array: GenericType[]): GenericType {\n  return array[lastIndex(array)]\n}\n\nexport function lastIndex<GenericType>(array: GenericType[]): number {\n  return Math.max(0, array.length - 1)\n}\n\nexport function removeClass(node: HTMLElement, className: string): void {\n  const cl = node.classList\n  if (className && cl.contains(className)) cl.remove(className)\n}\n\nexport function addClass(node: HTMLElement, className: string): void {\n  const cl = node.classList\n  if (className && !cl.contains(className)) cl.add(className)\n}\n","import { AnimationType } from './animation'\nimport { CounterType } from './counter'\nimport { DirectionType } from './direction'\nimport { DragTrackerType } from './dragTracker'\nimport { EventEmitterType } from './eventEmitter'\nimport { AxisType } from './axis'\nimport { EventStore } from './eventStore'\nimport { ScrollBodyType } from './scrollBody'\nimport { ScrollTargetType } from './scrollTarget'\nimport { ScrollToType } from './scrollTo'\nimport { Vector1D, Vector1DType } from './vector1d'\nimport { deltaAbs, factorAbs, mathSign } from './utils'\n\nexport type DragHandlerType = {\n  addActivationEvents: () => void\n  clickAllowed: () => boolean\n  pointerDown: () => boolean\n  removeAllEvents: () => void\n}\n\nexport function DragHandler(\n  axis: AxisType,\n  direction: DirectionType,\n  rootNode: HTMLElement,\n  target: Vector1DType,\n  dragFree: boolean,\n  dragTracker: DragTrackerType,\n  location: Vector1DType,\n  animation: AnimationType,\n  scrollTo: ScrollToType,\n  scrollBody: ScrollBodyType,\n  scrollTarget: ScrollTargetType,\n  index: CounterType,\n  events: EventEmitterType,\n  loop: boolean,\n  skipSnaps: boolean,\n): DragHandlerType {\n  const { scroll: scrollAxis, cross: crossAxis } = axis\n  const focusNodes = ['INPUT', 'SELECT', 'TEXTAREA']\n  const startScroll = Vector1D(0)\n  const startCross = Vector1D(0)\n  const dragStartPoint = Vector1D(0)\n  const activationEvents = EventStore()\n  const interactionEvents = EventStore()\n  const snapForceBoost = { mouse: 2.5, touch: 3.5 }\n  const freeForceBoost = { mouse: 5, touch: 7 }\n  const baseSpeed = dragFree ? 5 : 16\n  const baseMass = 1\n  const dragThreshold = 20\n\n  let pointerIsDown = false\n  let preventScroll = false\n  let preventClick = false\n  let isMouse = false\n\n  function addActivationEvents(): void {\n    const node = rootNode\n    activationEvents\n      .add(node, 'touchmove', () => undefined)\n      .add(node, 'touchend', () => undefined)\n      .add(node, 'touchstart', down)\n      .add(node, 'mousedown', down)\n      .add(node, 'touchcancel', up)\n      .add(node, 'contextmenu', up)\n      .add(node, 'click', click)\n  }\n\n  function addInteractionEvents(): void {\n    const node = !isMouse ? rootNode : document\n    interactionEvents\n      .add(node, 'touchmove', move)\n      .add(node, 'touchend', up)\n      .add(node, 'mousemove', move)\n      .add(node, 'mouseup', up)\n  }\n\n  function removeAllEvents(): void {\n    activationEvents.removeAll()\n    interactionEvents.removeAll()\n  }\n\n  function isFocusNode(node: Element): boolean {\n    const name = node.nodeName || ''\n    return focusNodes.indexOf(name) > -1\n  }\n\n  function forceBoost(): number {\n    const boost = dragFree ? freeForceBoost : snapForceBoost\n    const type = isMouse ? 'mouse' : 'touch'\n    return boost[type]\n  }\n\n  function allowedForce(force: number, targetChanged: boolean): number {\n    const next = index.clone().add(mathSign(force) * -1)\n    const isEdge = next.get() === index.min || next.get() === index.max\n    const baseForce = scrollTarget.byDistance(force, !dragFree).distance\n\n    if (dragFree || Math.abs(force) < dragThreshold) return baseForce\n    if (!loop && isEdge) return baseForce * 0.6\n    if (skipSnaps && targetChanged) return baseForce * 0.5\n\n    return scrollTarget.byIndex(next.get(), 0).distance\n  }\n\n  function down(evt: Event): void {\n    isMouse = evt.type === 'mousedown'\n    if (isMouse && (evt as MouseEvent).button !== 0) return\n\n    const isMoving = deltaAbs(target.get(), location.get()) >= 2\n    const clearPreventClick = isMouse || !isMoving\n    const isNotFocusNode = !isFocusNode(evt.target as Element)\n    const preventDefault = isMoving || (isMouse && isNotFocusNode)\n\n    pointerIsDown = true\n    dragTracker.pointerDown(evt)\n    dragStartPoint.set(target)\n    target.set(location)\n    scrollBody.useBaseMass().useSpeed(80)\n    addInteractionEvents()\n    startScroll.set(dragTracker.readPoint(evt, scrollAxis))\n    startCross.set(dragTracker.readPoint(evt, crossAxis))\n    events.emit('pointerDown')\n\n    if (clearPreventClick) preventClick = false\n    if (preventDefault) evt.preventDefault()\n  }\n\n  function move(evt: Event): void {\n    if (!preventScroll && !isMouse) {\n      if (!evt.cancelable) return up()\n      const moveScroll = dragTracker.readPoint(evt, scrollAxis).get()\n      const moveCross = dragTracker.readPoint(evt, crossAxis).get()\n      const diffScroll = deltaAbs(moveScroll, startScroll.get())\n      const diffCross = deltaAbs(moveCross, startCross.get())\n      preventScroll = diffScroll > diffCross\n      if (!preventScroll && !preventClick) return up()\n    }\n    const diff = dragTracker.pointerMove(evt)\n    if (!preventClick && diff) preventClick = true\n    animation.start()\n    target.add(direction.applyTo(diff))\n    evt.preventDefault()\n  }\n\n  function up(): void {\n    const currentLocation = scrollTarget.byDistance(0, false)\n    const targetChanged = currentLocation.index !== index.get()\n    const rawForce = dragTracker.pointerUp() * forceBoost()\n    const force = allowedForce(direction.applyTo(rawForce), targetChanged)\n    const forceFactor = factorAbs(rawForce, force)\n    const isMoving = deltaAbs(target.get(), dragStartPoint.get()) >= 0.5\n    const isVigorous = targetChanged && forceFactor > 0.75\n    const isBelowThreshold = Math.abs(rawForce) < dragThreshold\n    const speed = isVigorous ? 10 : baseSpeed\n    const mass = isVigorous ? baseMass + 2.5 * forceFactor : baseMass\n\n    if (isMoving && !isMouse) preventClick = true\n    preventScroll = false\n    pointerIsDown = false\n    interactionEvents.removeAll()\n    scrollBody.useSpeed(isBelowThreshold ? 9 : speed).useMass(mass)\n    scrollTo.distance(force, !dragFree)\n    isMouse = false\n    events.emit('pointerUp')\n  }\n\n  function click(evt: Event): void {\n    if (preventClick) evt.preventDefault()\n  }\n\n  function clickAllowed(): boolean {\n    return !preventClick\n  }\n\n  function pointerDown(): boolean {\n    return pointerIsDown\n  }\n\n  const self: DragHandlerType = {\n    addActivationEvents,\n    clickAllowed,\n    pointerDown,\n    removeAllEvents,\n  }\n  return self\n}\n","import { AxisOptionType, AxisType } from './axis'\nimport { PxToPercentType } from './pxToPercent'\nimport { Vector1D, Vector1DType } from './vector1d'\n\nexport type DragTrackerType = {\n  pointerDown: (evt: Event) => number\n  pointerMove: (evt: Event) => number\n  pointerUp: () => number\n  readPoint: (evt: any, axis: AxisOptionType) => Vector1DType\n}\n\nexport function DragTracker(\n  axis: AxisType,\n  pxToPercent: PxToPercentType,\n): DragTrackerType {\n  const { scroll: scrollAxis } = axis\n  const coords = { x: 'clientX', y: 'clientY' }\n  const startDrag = Vector1D(0)\n  const diffDrag = Vector1D(0)\n  const lastDrag = Vector1D(0)\n  const pointValue = Vector1D(0)\n  const trackInterval = 10\n  const trackLength = 5\n  const trackTime = 100\n  let trackPoints: number[] = []\n  let lastMoveTime = new Date().getTime()\n  let isMouse = false\n\n  function readPoint(evt: any, type: AxisOptionType): Vector1DType {\n    isMouse = !evt.touches\n    const c = coords[type]\n    const value = isMouse ? evt[c] : evt.touches[0][c]\n    return pointValue.set(value)\n  }\n\n  function pointerDown(evt: Event): number {\n    const point = readPoint(evt, scrollAxis)\n    startDrag.set(point)\n    lastDrag.set(point)\n    return pxToPercent.measure(startDrag.get())\n  }\n\n  function pointerMove(evt: Event): number {\n    const point = readPoint(evt, scrollAxis)\n    const nowTime = new Date().getTime()\n    const diffTime = nowTime - lastMoveTime\n\n    if (diffTime >= trackInterval) {\n      if (diffTime >= trackTime) trackPoints = []\n      trackPoints.push(point.get())\n      lastMoveTime = nowTime\n    }\n\n    diffDrag.set(point).subtract(lastDrag)\n    lastDrag.set(point)\n    return pxToPercent.measure(diffDrag.get())\n  }\n\n  function pointerUp(): number {\n    const nowTime = new Date().getTime()\n    const diffTime = nowTime - lastMoveTime\n    const currentPoint = lastDrag.get()\n\n    const force = trackPoints\n      .slice(-trackLength)\n      .map((trackPoint) => currentPoint - trackPoint)\n      .sort((p1, p2) => (Math.abs(p1) < Math.abs(p2) ? 1 : -1))[0]\n\n    lastDrag.set(diffTime > trackTime || !force ? 0 : force)\n    trackPoints = []\n    return pxToPercent.measure(lastDrag.get())\n  }\n\n  const self: DragTrackerType = {\n    pointerDown,\n    pointerMove,\n    pointerUp,\n    readPoint,\n  }\n  return self\n}\n","export type PxToPercentType = {\n  measure: (n: number) => number\n  totalPercent: number\n}\n\nexport function PxToPercent(viewInPx: number): PxToPercentType {\n  const totalPercent = 100\n\n  function measure(n: number): number {\n    if (viewInPx === 0) return 0\n    return (n / viewInPx) * totalPercent\n  }\n\n  const self: PxToPercentType = {\n    measure,\n    totalPercent,\n  }\n  return self\n}\n","import { map, roundToDecimals, mathSign } from './utils'\nimport { Vector1D, Vector1DType } from './vector1d'\n\nexport type ScrollBodyType = {\n  direction: () => number\n  seek: (v: Vector1DType) => ScrollBodyType\n  settle: (v: Vector1DType) => boolean\n  update: () => void\n  useBaseMass: () => ScrollBodyType\n  useBaseSpeed: () => ScrollBodyType\n  useMass: (n: number) => ScrollBodyType\n  useSpeed: (n: number) => ScrollBodyType\n}\n\nexport function ScrollBody(\n  location: Vector1DType,\n  baseSpeed: number,\n  baseMass: number,\n): ScrollBodyType {\n  const roundToTwoDecimals = roundToDecimals(2)\n  const velocity = Vector1D(0)\n  const acceleration = Vector1D(0)\n  const attraction = Vector1D(0)\n\n  let attractionDirection = 0\n  let speed = baseSpeed\n  let mass = baseMass\n\n  function update(): void {\n    velocity.add(acceleration)\n    location.add(velocity)\n    acceleration.multiply(0)\n  }\n\n  function applyForce(v: Vector1DType): void {\n    v.divide(mass)\n    acceleration.add(v)\n  }\n\n  function seek(v: Vector1DType): ScrollBodyType {\n    attraction.set(v).subtract(location)\n    const magnitude = map(attraction.get(), 0, 100, 0, speed)\n    attractionDirection = mathSign(attraction.get())\n    attraction.normalize().multiply(magnitude).subtract(velocity)\n    applyForce(attraction)\n    return self\n  }\n\n  function settle(v: Vector1DType): boolean {\n    const diff = v.get() - location.get()\n    const hasSettled = !roundToTwoDecimals(diff)\n    if (hasSettled) location.set(v)\n    return hasSettled\n  }\n\n  function direction(): number {\n    return attractionDirection\n  }\n\n  function useBaseSpeed(): ScrollBodyType {\n    return useSpeed(baseSpeed)\n  }\n\n  function useBaseMass(): ScrollBodyType {\n    return useMass(baseMass)\n  }\n\n  function useSpeed(n: number): ScrollBodyType {\n    speed = n\n    return self\n  }\n\n  function useMass(n: number): ScrollBodyType {\n    mass = n\n    return self\n  }\n\n  const self: ScrollBodyType = {\n    direction,\n    seek,\n    settle,\n    update,\n    useBaseMass,\n    useBaseSpeed,\n    useMass,\n    useSpeed,\n  }\n  return self\n}\n","import { LimitType } from './limit'\nimport { ScrollBodyType } from './scrollBody'\nimport { Vector1DType } from './vector1d'\n\nexport type ScrollBoundsType = {\n  constrain: (pointerDown: boolean) => void\n  toggleActive: (active: boolean) => void\n}\n\nexport function ScrollBounds(\n  limit: LimitType,\n  location: Vector1DType,\n  target: Vector1DType,\n  scrollBody: ScrollBodyType,\n): ScrollBoundsType {\n  const pullBackThreshold = 10\n  let disabled = false\n\n  function shouldConstrain(): boolean {\n    if (disabled) return false\n    if (!limit.reachedAny(target.get())) return false\n    if (!limit.reachedAny(location.get())) return false\n    return true\n  }\n\n  function constrain(pointerDown: boolean): void {\n    if (!shouldConstrain()) return\n    const friction = pointerDown ? 0.7 : 0.45\n    const diffToTarget = target.get() - location.get()\n\n    target.subtract(diffToTarget * friction)\n\n    if (!pointerDown && Math.abs(diffToTarget) < pullBackThreshold) {\n      target.set(limit.constrain(target.get()))\n      scrollBody.useSpeed(10).useMass(3)\n    }\n  }\n\n  function toggleActive(active: boolean): void {\n    disabled = !active\n  }\n\n  const self: ScrollBoundsType = {\n    constrain,\n    toggleActive,\n  }\n  return self\n}\n","import { Limit, LimitType } from './limit'\nimport { arrayLast } from './utils'\n\nexport type ScrollContainOptionType = '' | 'trimSnaps' | 'keepSnaps'\n\nexport type ScrollContainType = {\n  snapsContained: number[]\n}\n\nexport function ScrollContain(\n  viewSize: number,\n  contentSize: number,\n  snaps: number[],\n  snapsAligned: number[],\n  containScroll: ScrollContainOptionType,\n): ScrollContainType {\n  const scrollBounds = Limit(-contentSize + viewSize, snaps[0])\n  const snapsBounded = snapsAligned.map(scrollBounds.constrain)\n  const snapsContained = measureContained()\n\n  function findDuplicates(): LimitType {\n    const startSnap = snapsBounded[0]\n    const endSnap = arrayLast(snapsBounded)\n    const min = snapsBounded.lastIndexOf(startSnap)\n    const max = snapsBounded.indexOf(endSnap) + 1\n    return Limit(min, max)\n  }\n\n  function measureContained(): number[] {\n    if (contentSize <= viewSize) return [scrollBounds.max]\n    if (containScroll === 'keepSnaps') return snapsBounded\n    const { min, max } = findDuplicates()\n    return snapsBounded.slice(min, max)\n  }\n\n  const self: ScrollContainType = {\n    snapsContained,\n  }\n  return self\n}\n","import { Limit, LimitType } from './limit'\nimport { arrayLast } from './utils'\n\nexport type ScrollLimitType = {\n  limit: LimitType\n}\n\nexport function ScrollLimit(\n  contentSize: number,\n  scrollSnaps: number[],\n  loop: boolean,\n): ScrollLimitType {\n  const limit = measureLimit()\n\n  function measureLimit(): LimitType {\n    const startSnap = scrollSnaps[0]\n    const endSnap = arrayLast(scrollSnaps)\n    const min = loop ? startSnap - contentSize : endSnap\n    const max = startSnap\n    return Limit(min, max)\n  }\n\n  const self: ScrollLimitType = {\n    limit,\n  }\n  return self\n}\n","import { Limit, LimitType } from './limit'\nimport { PxToPercentType } from './pxToPercent'\nimport { Vector1DType } from './vector1d'\n\nexport type ScrollLooperType = {\n  loop: (direction: number) => void\n}\n\nexport function ScrollLooper(\n  contentSize: number,\n  pxToPercent: PxToPercentType,\n  limit: LimitType,\n  location: Vector1DType,\n  vectors: Vector1DType[],\n): ScrollLooperType {\n  const min = limit.min + pxToPercent.measure(0.1)\n  const max = limit.max + pxToPercent.measure(0.1)\n  const { reachedMin, reachedMax } = Limit(min, max)\n\n  function shouldLoop(direction: number): boolean {\n    if (direction === 1) return reachedMax(location.get())\n    if (direction === -1) return reachedMin(location.get())\n    return false\n  }\n\n  function loop(direction: number): void {\n    if (!shouldLoop(direction)) return\n\n    const loopDistance = contentSize * (direction * -1)\n    vectors.forEach((v) => v.add(loopDistance))\n  }\n\n  const self: ScrollLooperType = {\n    loop,\n  }\n  return self\n}\n","import { LimitType } from './limit'\n\nexport type ScrollProgressType = {\n  get: (n: number) => number\n}\n\nexport function ScrollProgress(limit: LimitType): ScrollProgressType {\n  const { max, length: scrollLength } = limit\n\n  function get(n: number): number {\n    const currentLocation = n - max\n    return currentLocation / -scrollLength\n  }\n\n  const self: ScrollProgressType = {\n    get,\n  }\n  return self\n}\n","import { AlignmentType } from './alignment'\nimport { AxisType } from './axis'\nimport { PxToPercentType } from './pxToPercent'\nimport { arrayLast, groupArray } from './utils'\n\nexport type ScrollSnapType = {\n  snaps: number[]\n  snapsAligned: number[]\n}\n\nexport function ScrollSnap(\n  axis: AxisType,\n  alignment: AlignmentType,\n  pxToPercent: PxToPercentType,\n  containerRect: DOMRect,\n  slideRects: DOMRect[],\n  slidesToScroll: number,\n): ScrollSnapType {\n  const { startEdge, endEdge } = axis\n  const snaps = measureUnaligned()\n  const snapsAligned = measureAligned()\n\n  function measureSizes(): number[] {\n    return groupArray(slideRects, slidesToScroll)\n      .map((rects) => arrayLast(rects)[endEdge] - rects[0][startEdge])\n      .map(pxToPercent.measure)\n      .map(Math.abs)\n  }\n\n  function measureUnaligned(): number[] {\n    return slideRects\n      .map((rect) => containerRect[startEdge] - rect[startEdge])\n      .map(pxToPercent.measure)\n      .map((snap) => -Math.abs(snap))\n  }\n\n  function measureAligned(): number[] {\n    const groupedSnaps = groupArray(snaps, slidesToScroll).map((g) => g[0])\n    const alignments = measureSizes().map(alignment.measure)\n    return groupedSnaps.map((snap, index) => snap + alignments[index])\n  }\n\n  const self: ScrollSnapType = {\n    snaps,\n    snapsAligned,\n  }\n  return self\n}\n","import { LimitType } from './limit'\nimport { Vector1DType } from './vector1d'\n\nexport type TargetType = {\n  distance: number\n  index: number\n}\n\nexport type ScrollTargetType = {\n  byIndex: (target: number, direction: number) => TargetType\n  byDistance: (force: number, snap: boolean) => TargetType\n  shortcut: (target: number, direction: number) => number\n}\n\nexport function ScrollTarget(\n  loop: boolean,\n  scrollSnaps: number[],\n  contentSize: number,\n  limit: LimitType,\n  targetVector: Vector1DType,\n): ScrollTargetType {\n  const { reachedAny, removeOffset, constrain } = limit\n\n  function minDistance(d1: number, d2: number): number {\n    return Math.abs(d1) < Math.abs(d2) ? d1 : d2\n  }\n\n  function findTargetSnap(target: number): TargetType {\n    const distance = loop ? removeOffset(target) : constrain(target)\n    const ascDiffsToSnaps = scrollSnaps\n      .map((scrollSnap) => scrollSnap - distance)\n      .map((diffToSnap) => shortcut(diffToSnap, 0))\n      .map((diff, i) => ({ diff, index: i }))\n      .sort((d1, d2) => Math.abs(d1.diff) - Math.abs(d2.diff))\n\n    const { index } = ascDiffsToSnaps[0]\n    return { index, distance }\n  }\n\n  function shortcut(target: number, direction: number): number {\n    const t1 = target\n    const t2 = target + contentSize\n    const t3 = target - contentSize\n\n    if (!loop) return t1\n    if (!direction) return minDistance(minDistance(t1, t2), t3)\n\n    const shortest = minDistance(t1, direction === 1 ? t2 : t3)\n    return Math.abs(shortest) * direction\n  }\n\n  function byIndex(index: number, direction: number): TargetType {\n    const diffToSnap = scrollSnaps[index] - targetVector.get()\n    const distance = shortcut(diffToSnap, direction)\n    return { index, distance }\n  }\n\n  function byDistance(distance: number, snap: boolean): TargetType {\n    const target = targetVector.get() + distance\n    const { index, distance: targetSnapDistance } = findTargetSnap(target)\n    const reachedBound = !loop && reachedAny(target)\n\n    if (!snap || reachedBound) return { index, distance }\n\n    const diffToSnap = scrollSnaps[index] - targetSnapDistance\n    const snapDistance = distance + shortcut(diffToSnap, 0)\n\n    return { index, distance: snapDistance }\n  }\n\n  const self: ScrollTargetType = {\n    byDistance,\n    byIndex,\n    shortcut,\n  }\n  return self\n}\n","import { AnimationType } from './animation'\nimport { CounterType } from './counter'\nimport { EventEmitterType } from './eventEmitter'\nimport { ScrollTargetType, TargetType } from './scrollTarget'\nimport { Vector1DType } from './vector1d'\n\nexport type ScrollToType = {\n  distance: (n: number, snap: boolean) => void\n  index: (n: number, direction: number) => void\n}\n\nexport function ScrollTo(\n  animation: AnimationType,\n  indexCurrent: CounterType,\n  indexPrevious: CounterType,\n  scrollTarget: ScrollTargetType,\n  targetVector: Vector1DType,\n  events: EventEmitterType,\n): ScrollToType {\n  function scrollTo(target: TargetType): void {\n    const distanceDiff = target.distance\n    const indexDiff = target.index !== indexCurrent.get()\n\n    if (distanceDiff) {\n      animation.start()\n      targetVector.add(distanceDiff)\n    }\n    if (indexDiff) {\n      indexPrevious.set(indexCurrent.get())\n      indexCurrent.set(target.index)\n      events.emit('select')\n    }\n  }\n\n  function distance(n: number, snap: boolean): void {\n    const target = scrollTarget.byDistance(n, snap)\n    scrollTo(target)\n  }\n\n  function index(n: number, direction: number): void {\n    const targetIndex = indexCurrent.clone().set(n)\n    const target = scrollTarget.byIndex(targetIndex.get(), direction)\n    scrollTo(target)\n  }\n\n  const self: ScrollToType = {\n    distance,\n    index,\n  }\n  return self\n}\n","import { AxisType } from './axis'\nimport { arrayKeys } from './utils'\nimport { SlidesInViewType } from './slidesInView'\nimport { Vector1DType } from './vector1d'\n\ntype EdgeType = 'start' | 'end'\n\ntype LoopPointType = {\n  point: number\n  location: number\n  index: number\n  getTarget: () => number\n}\n\nexport type SlideLooperType = {\n  canLoop: () => boolean\n  clear: () => void\n  loop: () => void\n  loopPoints: LoopPointType[]\n}\n\nexport function SlideLooper(\n  axis: AxisType,\n  viewSize: number,\n  contentSize: number,\n  slideSizesWithGaps: number[],\n  scrollSnaps: number[],\n  slidesInView: SlidesInViewType,\n  scrollLocation: Vector1DType,\n  slides: HTMLElement[],\n): SlideLooperType {\n  const ascItems = arrayKeys(slideSizesWithGaps)\n  const descItems = arrayKeys(slideSizesWithGaps).reverse()\n  const loopPoints = startPoints().concat(endPoints())\n\n  function removeSlideSizes(indexes: number[], from: number): number {\n    return indexes.reduce((a: number, i) => {\n      return a - slideSizesWithGaps[i]\n    }, from)\n  }\n\n  function slidesInGap(indexes: number[], gap: number): number[] {\n    return indexes.reduce((a: number[], i) => {\n      const remainingGap = removeSlideSizes(a, gap)\n      return remainingGap > 0 ? a.concat([i]) : a\n    }, [])\n  }\n\n  function findLoopPoints(indexes: number[], edge: EdgeType): LoopPointType[] {\n    const isStartEdge = edge === 'start'\n    const offset = isStartEdge ? -contentSize : contentSize\n    const slideBounds = slidesInView.findSlideBounds(offset)\n\n    return indexes.map((index) => {\n      const initial = isStartEdge ? 0 : -contentSize\n      const altered = isStartEdge ? contentSize : 0\n      const bounds = slideBounds.filter((b) => b.index === index)[0]\n      const point = bounds[isStartEdge ? 'end' : 'start']\n      const getTarget = (): number =>\n        scrollLocation.get() > point ? initial : altered\n      return { point, getTarget, index, location: -1 }\n    })\n  }\n\n  function startPoints(): LoopPointType[] {\n    const gap = scrollSnaps[0] - 1\n    const indexes = slidesInGap(descItems, gap)\n    return findLoopPoints(indexes, 'end')\n  }\n\n  function endPoints(): LoopPointType[] {\n    const gap = viewSize - scrollSnaps[0] - 1\n    const indexes = slidesInGap(ascItems, gap)\n    return findLoopPoints(indexes, 'start')\n  }\n\n  function canLoop(): boolean {\n    return loopPoints.every(({ index }) => {\n      const otherIndexes = ascItems.filter((i) => i !== index)\n      return removeSlideSizes(otherIndexes, viewSize) <= 0\n    })\n  }\n\n  function loop(): void {\n    loopPoints.forEach((loopPoint) => {\n      const { getTarget, location, index } = loopPoint\n      const target = getTarget()\n      if (target !== location) {\n        slides[index].style[axis.startEdge] = `${target}%`\n        loopPoint.location = target\n      }\n    })\n  }\n\n  function clear(): void {\n    loopPoints.forEach(({ index }) => {\n      slides[index].style[axis.startEdge] = ''\n    })\n  }\n\n  const self: SlideLooperType = {\n    canLoop,\n    clear,\n    loop,\n    loopPoints,\n  }\n  return self\n}\n","import { EventStore, EventStoreType } from './eventStore'\nimport { ScrollToType } from './scrollTo'\n\nexport type SlideFocusType = {\n  addActivationEvents: (slides: HTMLElement[]) => void\n  removeAllEvents: EventStoreType['removeAll']\n}\n\nexport function SlideFocus(\n  rootNode: HTMLElement,\n  scrollTo: ScrollToType,\n  slidesToScroll: number,\n): SlideFocusType {\n  const eventStore = EventStore()\n  const removeAllEvents = eventStore.removeAll\n  let lastTabPressTime = 0\n\n  function registerTabPress(event: Event): void {\n    if ((event as KeyboardEvent).keyCode !== 9) return\n    lastTabPressTime = new Date().getTime()\n  }\n\n  function addFocusEvent(slide: HTMLElement, index: number): void {\n    const focus = (): void => {\n      const nowTime = new Date().getTime()\n      const diffTime = nowTime - lastTabPressTime\n      if (diffTime > 10) return\n\n      rootNode.scrollLeft = 0\n      const selectedIndex = Math.floor(index / slidesToScroll)\n      scrollTo.index(selectedIndex, 0)\n    }\n    eventStore.add(slide, 'focus', focus, true)\n  }\n\n  function addActivationEvents(slides: HTMLElement[]): void {\n    eventStore.add(document, 'keydown', registerTabPress, false)\n    slides.forEach(addFocusEvent)\n  }\n\n  const self: SlideFocusType = {\n    addActivationEvents,\n    removeAllEvents,\n  }\n  return self\n}\n","type SlideBoundType = {\n  start: number\n  end: number\n  index: number\n}\n\nexport type SlidesInViewType = {\n  check: (location: number) => number[]\n  findSlideBounds: (offset: number, threshold?: number) => SlideBoundType[]\n}\n\nexport function SlidesInView(\n  viewSize: number,\n  contentSize: number,\n  slideSizes: number[],\n  snaps: number[],\n  loop: boolean,\n  inViewThreshold: number,\n): SlidesInViewType {\n  const threshold = Math.min(Math.max(inViewThreshold, 0.01), 0.99)\n  const offsets = loop ? [0, contentSize, -contentSize] : [0]\n  const slideBounds = offsets.reduce((a: SlideBoundType[], offset) => {\n    return a.concat(findSlideBounds(offset, threshold))\n  }, [])\n\n  function findSlideBounds(\n    offset: number,\n    threshold?: number,\n  ): SlideBoundType[] {\n    const thresholds = slideSizes.map((s) => s * (threshold || 0))\n    return snaps.map((snap, index) => ({\n      start: snap - slideSizes[index] + thresholds[index] + offset,\n      end: snap + viewSize - thresholds[index] + offset,\n      index,\n    }))\n  }\n\n  function check(location: number): number[] {\n    return slideBounds.reduce((list: number[], slideBound) => {\n      const { index, start, end } = slideBound\n      const inList = list.indexOf(index) !== -1\n      const inView = start < location && end > location\n      return !inList && inView ? list.concat([index]) : list\n    }, [])\n  }\n\n  const self: SlidesInViewType = {\n    check,\n    findSlideBounds,\n  }\n  return self\n}\n","import { AxisType } from './axis'\nimport { PxToPercentType } from './pxToPercent'\nimport { arrayLast, lastIndex } from './utils'\n\nexport type SlideSizesType = {\n  slideSizes: number[]\n  slideSizesWithGaps: number[]\n}\n\nexport function SlideSizes(\n  axis: AxisType,\n  pxToPercent: PxToPercentType,\n  slides: HTMLElement[],\n  slideRects: DOMRect[],\n  loop: boolean,\n): SlideSizesType {\n  const { measureSize, startEdge, endEdge } = axis\n  const sizesInPx = slideRects.map(measureSize)\n  const slideSizes = sizesInPx.map(pxToPercent.measure)\n  const slideSizesWithGaps = measureWithGaps()\n\n  function measureWithGaps(): number[] {\n    return slideRects\n      .map((rect, index, rects) => {\n        const isLast = index === lastIndex(rects)\n        const style = window.getComputedStyle(arrayLast(slides))\n        const endGap = parseFloat(style.getPropertyValue(`margin-${endEdge}`))\n        if (isLast) return sizesInPx[index] + (loop ? endGap : 0)\n        return rects[index + 1][startEdge] - rect[startEdge]\n      })\n      .map(pxToPercent.measure)\n      .map(Math.abs)\n  }\n\n  const self: SlideSizesType = {\n    slideSizes,\n    slideSizesWithGaps,\n  }\n  return self\n}\n","import { AxisType } from './axis'\nimport { DirectionType } from './direction'\nimport { Vector1DType } from './vector1d'\n\nexport type TranslateType = {\n  clear: () => void\n  to: (vector: Vector1DType) => void\n  toggleActive: (active: boolean) => void\n}\n\nexport function Translate(\n  axis: AxisType,\n  direction: DirectionType,\n  container: HTMLElement,\n): TranslateType {\n  const containerStyle = container.style\n  const translate = axis.scroll === 'x' ? x : y\n  let disabled = false\n\n  function x(n: number): string {\n    return `translate3d(${n}%,0px,0px)`\n  }\n\n  function y(n: number): string {\n    return `translate3d(0px,${n}%,0px)`\n  }\n\n  function to(target: Vector1DType): void {\n    if (disabled) return\n    containerStyle.transform = translate(direction.applyTo(target.get()))\n  }\n\n  function toggleActive(active: boolean): void {\n    disabled = !active\n  }\n\n  function clear(): void {\n    containerStyle.transform = ''\n  }\n\n  const self: TranslateType = {\n    clear,\n    to,\n    toggleActive,\n  }\n  return self\n}\n","import { Alignment } from './alignment'\nimport { Animation, AnimationType } from './animation'\nimport { Axis, AxisType } from './axis'\nimport { Counter, CounterType } from './counter'\nimport { Direction, DirectionType } from './direction'\nimport { DragHandler, DragHandlerType } from './dragHandler'\nimport { DragTracker } from './dragTracker'\nimport { EventEmitterType } from './eventEmitter'\nimport { LimitType } from './limit'\nimport { OptionsType } from './options'\nimport { PxToPercent, PxToPercentType } from './pxToPercent'\nimport { ScrollBody, ScrollBodyType } from './scrollBody'\nimport { ScrollBounds, ScrollBoundsType } from './scrollBounds'\nimport { ScrollContain } from './scrollContain'\nimport { ScrollLimit } from './scrollLimit'\nimport { ScrollLooper, ScrollLooperType } from './scrollLooper'\nimport { ScrollProgress, ScrollProgressType } from './scrollProgress'\nimport { ScrollSnap } from './scrollSnap'\nimport { ScrollTarget, ScrollTargetType } from './scrollTarget'\nimport { ScrollTo, ScrollToType } from './scrollTo'\nimport { SlideLooper, SlideLooperType } from './slideLooper'\nimport { SlideFocus, SlideFocusType } from './slideFocus'\nimport { SlidesInView, SlidesInViewType } from './slidesInView'\nimport { SlideSizes } from './slideSizes'\nimport { Translate, TranslateType } from './translate'\nimport { arrayKeys, arrayLast, lastIndex } from './utils'\nimport { Vector1D, Vector1DType } from './vector1d'\n\nexport type Engine = {\n  axis: AxisType\n  direction: DirectionType\n  animation: AnimationType\n  scrollBounds: ScrollBoundsType\n  scrollLooper: ScrollLooperType\n  scrollProgress: ScrollProgressType\n  index: CounterType\n  indexPrevious: CounterType\n  limit: LimitType\n  location: Vector1DType\n  options: OptionsType\n  pxToPercent: PxToPercentType\n  scrollBody: ScrollBodyType\n  dragHandler: DragHandlerType\n  slideFocus: SlideFocusType\n  slideLooper: SlideLooperType\n  slidesInView: SlidesInViewType\n  target: Vector1DType\n  translate: TranslateType\n  scrollTo: ScrollToType\n  scrollTarget: ScrollTargetType\n  scrollSnaps: number[]\n  slideIndexes: number[]\n}\n\nexport function Engine(\n  root: HTMLElement,\n  container: HTMLElement,\n  slides: HTMLElement[],\n  options: OptionsType,\n  events: EventEmitterType,\n): Engine {\n  // Options\n  const {\n    align,\n    axis: scrollAxis,\n    direction: contentDirection,\n    startIndex,\n    inViewThreshold,\n    loop,\n    speed,\n    dragFree,\n    slidesToScroll,\n    skipSnaps,\n    containScroll,\n  } = options\n\n  // Measurements\n  const containerRect = container.getBoundingClientRect()\n  const slideRects = slides.map((slide) => slide.getBoundingClientRect())\n  const direction = Direction(contentDirection)\n  const axis = Axis(scrollAxis, contentDirection)\n  const pxToPercent = PxToPercent(axis.measureSize(containerRect))\n  const viewSize = pxToPercent.totalPercent\n  const alignment = Alignment(align, viewSize)\n  const { slideSizes, slideSizesWithGaps } = SlideSizes(\n    axis,\n    pxToPercent,\n    slides,\n    slideRects,\n    loop,\n  )\n  const { snaps, snapsAligned } = ScrollSnap(\n    axis,\n    alignment,\n    pxToPercent,\n    containerRect,\n    slideRects,\n    slidesToScroll,\n  )\n  const contentSize = -arrayLast(snaps) + arrayLast(slideSizesWithGaps)\n  const { snapsContained } = ScrollContain(\n    viewSize,\n    contentSize,\n    snaps,\n    snapsAligned,\n    containScroll,\n  )\n\n  const contain = !loop && containScroll !== ''\n  const scrollSnaps = contain ? snapsContained : snapsAligned\n  const { limit } = ScrollLimit(contentSize, scrollSnaps, loop)\n\n  // Indexes\n  const index = Counter(lastIndex(scrollSnaps), startIndex, loop)\n  const indexPrevious = index.clone()\n  const slideIndexes = arrayKeys(slides)\n\n  // Draw\n  const update = (): void => {\n    if (!loop) engine.scrollBounds.constrain(engine.dragHandler.pointerDown())\n    engine.scrollBody.seek(target).update()\n    const settled = engine.scrollBody.settle(target)\n\n    if (settled && !engine.dragHandler.pointerDown()) {\n      engine.animation.stop()\n      events.emit('settle')\n    }\n    if (!settled) {\n      events.emit('scroll')\n    }\n    if (loop) {\n      engine.scrollLooper.loop(engine.scrollBody.direction())\n      engine.slideLooper.loop()\n    }\n\n    engine.translate.to(location)\n    engine.animation.proceed()\n  }\n\n  // Shared\n  const animation = Animation(update)\n  const startLocation = scrollSnaps[index.get()]\n  const location = Vector1D(startLocation)\n  const target = Vector1D(startLocation)\n  const scrollBody = ScrollBody(location, speed, 1)\n  const scrollTarget = ScrollTarget(\n    loop,\n    scrollSnaps,\n    contentSize,\n    limit,\n    target,\n  )\n  const scrollTo = ScrollTo(\n    animation,\n    index,\n    indexPrevious,\n    scrollTarget,\n    target,\n    events,\n  )\n  const slidesInView = SlidesInView(\n    viewSize,\n    contentSize,\n    slideSizes,\n    snaps,\n    loop,\n    inViewThreshold,\n  )\n\n  // DragHandler\n  const dragHandler = DragHandler(\n    axis,\n    direction,\n    root,\n    target,\n    dragFree,\n    DragTracker(axis, pxToPercent),\n    location,\n    animation,\n    scrollTo,\n    scrollBody,\n    scrollTarget,\n    index,\n    events,\n    loop,\n    skipSnaps,\n  )\n\n  // Slider\n  const engine: Engine = {\n    animation,\n    axis,\n    direction,\n    dragHandler,\n    pxToPercent,\n    index,\n    indexPrevious,\n    limit,\n    location,\n    options,\n    scrollBody,\n    scrollBounds: ScrollBounds(limit, location, target, scrollBody),\n    scrollLooper: ScrollLooper(contentSize, pxToPercent, limit, location, [\n      location,\n      target,\n    ]),\n    scrollProgress: ScrollProgress(limit),\n    scrollSnaps,\n    scrollTarget,\n    scrollTo,\n    slideFocus: SlideFocus(root, scrollTo, slidesToScroll),\n    slideLooper: SlideLooper(\n      axis,\n      viewSize,\n      contentSize,\n      slideSizesWithGaps,\n      scrollSnaps,\n      slidesInView,\n      location,\n      slides,\n    ),\n    slidesInView,\n    slideIndexes,\n    target,\n    translate: Translate(axis, direction, container),\n  }\n  return engine\n}\n","type CallbackType = (evt: EmblaEventType) => void\ntype ListenersType = Partial<{ [key in EmblaEventType]: CallbackType[] }>\n\nexport type EmblaEventType =\n  | 'init'\n  | 'pointerDown'\n  | 'pointerUp'\n  | 'scroll'\n  | 'select'\n  | 'settle'\n  | 'destroy'\n  | 'reInit'\n  | 'resize'\n\nexport type EventEmitterType = {\n  emit: (evt: EmblaEventType) => EventEmitterType\n  on: (evt: EmblaEventType, cb: CallbackType) => EventEmitterType\n  off: (evt: EmblaEventType, cb: CallbackType) => EventEmitterType\n}\n\nexport function EventEmitter(): EventEmitterType {\n  const listeners: ListenersType = {}\n\n  function getListeners(evt: EmblaEventType): CallbackType[] {\n    const eventListeners = listeners[evt]\n    return eventListeners || []\n  }\n\n  function emit(evt: EmblaEventType): EventEmitterType {\n    getListeners(evt).forEach((e) => e(evt))\n    return self\n  }\n\n  function on(evt: EmblaEventType, cb: CallbackType): EventEmitterType {\n    listeners[evt] = getListeners(evt).concat([cb])\n    return self\n  }\n\n  function off(evt: EmblaEventType, cb: CallbackType): EventEmitterType {\n    listeners[evt] = getListeners(evt).filter((e) => e !== cb)\n    return self\n  }\n\n  const self: EventEmitterType = {\n    emit,\n    off,\n    on,\n  }\n  return self\n}\n","import { AlignmentOptionType } from './alignment'\nimport { AxisOptionType } from './axis'\nimport { DirectionOptionType } from './direction'\nimport { ScrollContainOptionType } from './scrollContain'\n\nexport type OptionsType = {\n  align: AlignmentOptionType\n  axis: AxisOptionType\n  containScroll: ScrollContainOptionType\n  direction: DirectionOptionType\n  dragFree: boolean\n  draggable: boolean\n  draggableClass: string\n  draggingClass: string\n  inViewThreshold: number\n  loop: boolean\n  skipSnaps: boolean\n  selectedClass: string\n  slidesToScroll: number\n  speed: number\n  startIndex: number\n}\n\nexport const defaultOptions: OptionsType = {\n  align: 'center',\n  axis: 'x',\n  containScroll: '',\n  direction: 'ltr',\n  dragFree: false,\n  draggable: true,\n  draggableClass: 'is-draggable',\n  draggingClass: 'is-dragging',\n  inViewThreshold: 0,\n  loop: false,\n  skipSnaps: true,\n  selectedClass: 'is-selected',\n  slidesToScroll: 1,\n  speed: 10,\n  startIndex: 0,\n}\n\nexport type EmblaOptionsType = Partial<OptionsType>\n","import { EmblaOptionsType } from './options'\n\nexport type OptionsPseudoType = {\n  get: () => EmblaOptionsType\n}\n\nexport function OptionsPseudo(node: HTMLElement): OptionsPseudoType {\n  const pseudoString = getComputedStyle(node, ':before').content\n\n  function get(): EmblaOptionsType {\n    try {\n      return JSON.parse(pseudoString.slice(1, -1).replace(/\\\\/g, ''))\n    } catch (error) {} // eslint-disable-line no-empty\n    return {}\n  }\n\n  const self: OptionsPseudoType = {\n    get,\n  }\n  return self\n}\n","import { Engine } from './engine'\nimport { EventStore } from './eventStore'\nimport { EventEmitter, EmblaEventType, EventEmitterType } from './eventEmitter'\nimport { defaultOptions, EmblaOptionsType } from './options'\nimport { OptionsPseudo, OptionsPseudoType } from './optionsPseudo'\nimport { addClass, debounce, removeClass } from './utils'\n\nexport type EmblaCarouselType = {\n  canScrollNext: () => boolean\n  canScrollPrev: () => boolean\n  clickAllowed: () => boolean\n  containerNode: () => HTMLElement\n  dangerouslyGetEngine: () => Engine\n  destroy: () => void\n  off: EventEmitterType['off']\n  on: EventEmitterType['on']\n  previousScrollSnap: () => number\n  reInit: (options?: EmblaOptionsType) => void\n  rootNode: () => HTMLElement\n  scrollNext: (jump?: boolean) => void\n  scrollPrev: (jump?: boolean) => void\n  scrollProgress: () => number\n  scrollSnapList: () => number[]\n  scrollTo: (index: number, jump?: boolean) => void\n  selectedScrollSnap: () => number\n  slideNodes: () => HTMLElement[]\n  slidesInView: (target?: boolean) => number[]\n  slidesNotInView: (target?: boolean) => number[]\n}\n\nfunction EmblaCarousel(\n  sliderRoot: HTMLElement,\n  userOptions?: EmblaOptionsType,\n): EmblaCarouselType {\n  const events = EventEmitter()\n  const eventStore = EventStore()\n  const debouncedResize = debounce(resize, 500)\n  const reInit = reActivate\n  const { on, off } = events\n\n  let engine: Engine\n  let activated = false\n  let optionsBase = Object.assign({}, defaultOptions)\n  let options = Object.assign({}, optionsBase)\n  let optionsPseudo: OptionsPseudoType\n  let rootNodeSize = 0\n  let container: HTMLElement\n  let slides: HTMLElement[]\n\n  activate(userOptions)\n\n  function setupElements(): void {\n    if (!sliderRoot) throw new Error('Missing root node 😢')\n    const sliderContainer = sliderRoot.querySelector('*')\n    if (!sliderContainer) throw new Error('Missing container node 😢')\n\n    container = sliderContainer as HTMLElement\n    slides = Array.prototype.slice.call(container.children)\n    optionsPseudo = OptionsPseudo(sliderRoot)\n  }\n\n  function activate(partialOptions?: EmblaOptionsType): void {\n    setupElements()\n    optionsBase = Object.assign({}, optionsBase, partialOptions)\n    options = Object.assign({}, optionsBase, optionsPseudo.get())\n    engine = Engine(sliderRoot, container, slides, options, events)\n    eventStore.add(window, 'resize', debouncedResize)\n    engine.translate.to(engine.location)\n    rootNodeSize = engine.axis.measureSize(sliderRoot.getBoundingClientRect())\n\n    if (options.loop) {\n      if (!engine.slideLooper.canLoop()) {\n        deActivate()\n        return activate({ loop: false })\n      }\n      engine.slideLooper.loop()\n    }\n    if (options.draggable && container.offsetParent && slides.length) {\n      engine.dragHandler.addActivationEvents()\n      if (options.draggableClass) {\n        addClass(sliderRoot, options.draggableClass)\n      }\n      if (options.draggingClass) {\n        events\n          .on('pointerDown', toggleDraggingClass)\n          .on('pointerUp', toggleDraggingClass)\n      }\n    }\n    if (slides.length) {\n      engine.slideFocus.addActivationEvents(slides)\n    }\n    if (options.selectedClass) {\n      toggleSelectedClass()\n      events\n        .on('select', toggleSelectedClass)\n        .on('pointerUp', toggleSelectedClass)\n    }\n    if (!activated) {\n      setTimeout(() => events.emit('init'), 0)\n      activated = true\n    }\n  }\n\n  function toggleDraggingClass(evt: EmblaEventType): void {\n    const { draggingClass } = options\n    if (evt === 'pointerDown') addClass(sliderRoot, draggingClass)\n    else removeClass(sliderRoot, draggingClass)\n  }\n\n  function toggleSelectedClass(): void {\n    const { selectedClass } = options\n    const inView = slidesInView(true)\n    const notInView = slidesNotInView(true)\n    notInView.forEach((index) => removeClass(slides[index], selectedClass))\n    inView.forEach((index) => addClass(slides[index], selectedClass))\n  }\n\n  function deActivate(): void {\n    engine.dragHandler.removeAllEvents()\n    engine.slideFocus.removeAllEvents()\n    engine.animation.stop()\n    eventStore.removeAll()\n    engine.translate.clear()\n    engine.slideLooper.clear()\n    removeClass(sliderRoot, options.draggableClass)\n    slides.forEach((slide) => removeClass(slide, options.selectedClass))\n    events\n      .off('select', toggleSelectedClass)\n      .off('pointerUp', toggleSelectedClass)\n      .off('pointerDown', toggleDraggingClass)\n      .off('pointerUp', toggleDraggingClass)\n  }\n\n  function reActivate(partialOptions?: EmblaOptionsType): void {\n    if (!activated) return\n    const startIndex = selectedScrollSnap()\n    const newOptions = Object.assign({ startIndex }, partialOptions)\n    deActivate()\n    activate(newOptions)\n    events.emit('reInit')\n  }\n\n  function destroy(): void {\n    if (!activated) return\n    deActivate()\n    activated = false\n    events.emit('destroy')\n  }\n\n  function resize(): void {\n    if (!activated) return\n    const size = engine.axis.measureSize(sliderRoot.getBoundingClientRect())\n    if (rootNodeSize !== size) reActivate()\n    events.emit('resize')\n  }\n\n  function slidesInView(target?: boolean): number[] {\n    const location = engine[target ? 'target' : 'location'].get()\n    const type = options.loop ? 'removeOffset' : 'constrain'\n    return engine.slidesInView.check(engine.limit[type](location))\n  }\n\n  function slidesNotInView(target?: boolean): number[] {\n    const inView = slidesInView(target)\n    return engine.slideIndexes.filter((index) => inView.indexOf(index) === -1)\n  }\n\n  function scrollTo(index: number, jump?: boolean, direction?: number): void {\n    engine.scrollBody.useBaseMass().useSpeed(jump ? 100 : options.speed)\n    if (activated) engine.scrollTo.index(index, direction || 0)\n  }\n\n  function scrollNext(jump?: boolean): void {\n    const next = engine.index.clone().add(1)\n    scrollTo(next.get(), jump === true, -1)\n  }\n\n  function scrollPrev(jump?: boolean): void {\n    const prev = engine.index.clone().add(-1)\n    scrollTo(prev.get(), jump === true, 1)\n  }\n\n  function canScrollNext(): boolean {\n    const next = engine.index.clone().add(1)\n    return next.get() !== selectedScrollSnap()\n  }\n\n  function canScrollPrev(): boolean {\n    const prev = engine.index.clone().add(-1)\n    return prev.get() !== selectedScrollSnap()\n  }\n\n  function scrollSnapList(): number[] {\n    return engine.scrollSnaps.map(engine.scrollProgress.get)\n  }\n\n  function scrollProgress(): number {\n    return engine.scrollProgress.get(engine.location.get())\n  }\n\n  function selectedScrollSnap(): number {\n    return engine.index.get()\n  }\n\n  function previousScrollSnap(): number {\n    return engine.indexPrevious.get()\n  }\n\n  function clickAllowed(): boolean {\n    return engine.dragHandler.clickAllowed()\n  }\n\n  function dangerouslyGetEngine(): Engine {\n    return engine\n  }\n\n  function rootNode(): HTMLElement {\n    return sliderRoot\n  }\n\n  function containerNode(): HTMLElement {\n    return container\n  }\n\n  function slideNodes(): HTMLElement[] {\n    return slides\n  }\n\n  const self: EmblaCarouselType = {\n    canScrollNext,\n    canScrollPrev,\n    clickAllowed,\n    containerNode,\n    dangerouslyGetEngine,\n    destroy,\n    off,\n    on,\n    previousScrollSnap,\n    reInit,\n    rootNode,\n    scrollNext,\n    scrollPrev,\n    scrollProgress,\n    scrollSnapList,\n    scrollTo,\n    selectedScrollSnap,\n    slideNodes,\n    slidesInView,\n    slidesNotInView,\n  }\n  return self\n}\n\nexport default EmblaCarousel\n","export function canUseDOM(): boolean {\n  return !!(\n    typeof window !== 'undefined' &&\n    window.document &&\n    window.document.createElement\n  )\n}\n\nexport function areEqualShallow(\n  objectA: { [key: string]: any },\n  objectB: { [key: string]: any },\n): boolean {\n  return (\n    Object.keys(objectA).length === Object.keys(objectB).length &&\n    Object.keys(objectA).every((objectKey) => {\n      if (!Object.prototype.hasOwnProperty.call(objectB, objectKey)) {\n        return false\n      }\n      return objectA[objectKey] === objectB[objectKey]\n    })\n  )\n}\n","import { useRef, useEffect, useState, useMemo } from 'react'\nimport EmblaCarousel, { EmblaCarouselType } from '../embla-carousel-vanilla'\nimport { EmblaOptionsType } from '../embla-carousel-vanilla/options'\nimport { areEqualShallow, canUseDOM } from './utils'\n\ntype ViewportRefType = <ViewportElement extends HTMLElement>(\n  instance: ViewportElement | null,\n) => void\n\nexport type UseEmblaCarouselType = [\n  ViewportRefType,\n  EmblaCarouselType | undefined,\n]\n\nfunction useEmblaCarousel(\n  options: EmblaOptionsType = {},\n): UseEmblaCarouselType {\n  const [embla, setEmbla] = useState<EmblaCarouselType>()\n  const [viewport, setViewport] = useState<HTMLElement>()\n  const storedOptions = useRef<EmblaOptionsType>(options)\n  const activeOptions = useMemo<EmblaOptionsType>(() => {\n    if (!areEqualShallow(storedOptions.current, options)) {\n      storedOptions.current = options\n    }\n    return storedOptions.current\n  }, [storedOptions, options])\n\n  useEffect(() => {\n    if (canUseDOM() && viewport) {\n      const newEmbla = EmblaCarousel(viewport, activeOptions)\n      setEmbla(newEmbla)\n      return () => newEmbla.destroy()\n    } else {\n      setEmbla(undefined)\n    }\n  }, [viewport, activeOptions, setEmbla])\n\n  return [setViewport as ViewportRefType, embla]\n}\n\nexport { useEmblaCarousel }\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}